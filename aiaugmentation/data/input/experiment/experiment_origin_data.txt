The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.
MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type
MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list
MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map
MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod
MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()
MicroPython shall support the following function from the module sys as defined in Python 3.4: sys.exit([code]). If code  argument is missing, then the default valueshall be taken. Upon completion with sys.exita SystemExit exception shall 
be raised and the C function starting the Virtual Machine execution shall return the given code-value bitwise ORed with 128.
MicroPython shall support the following function from the module array as defined in Python 3.4: array.array(typecode[, initialiser])
MicroPython shall support the following functions from the module ucollections as defined in Python 3.4 under the name collections : ucollections.namedtuple
MicroPython shall support the following functions from the module math as defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)
MicroPython shall support the following functions from the module struct as defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)
MicroPython shall support the following functions from the module binascii as defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)
MicroPython shall allow for using custom modules developed in C.
The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode execution ends, the function shall return the return code (0 if no error code is specified). The MicroPython Virtual Machine shall not modify or remove the bytecode.
If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise a specific exception.
If the MicroPython Virtual Machine catches an exception during execution (uncaught by the MicroPython bytecode itself), it shall stop, return a specific error code and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.
The MicroPython language shall support object-orientation, as defined in Python 3.4
MicroPython cross-compiler shall be provided. It shall generate a bytecode file, having .mpy extension, from a given MicroPython script that is syntactically valid.
The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin file with the content of the .mpy  file appended with the ISO checksum (2 bytes).
If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid line. No bytecode file shall be generated in such case.
After being loaded in memory, the byte code generated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.
The MicroPython Software Development Environment shall provide a preprocessing tool called "Import Expander". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.
The Import Expander shall be able to do "smart expansion": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.
The Import Expander shall be able to report all the names that have been retained by the "smart expansion".
The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.
The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.
Each function provided by the rtems module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFUL then the function shall raise a Python OSError exception with a single argument, which is the string corresponding to the rtems_status_code.
Software Development Environment shall be provided for developing MicroPython procedure. This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.
The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.
If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.
The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy file.
The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.
The Virtual Machine test suite shall be automated.
The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.
The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.
The MicroPython Virtual Machine shall be designed to execute the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.
The MicroPython cross-compiler source code and/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM / RAM size) or for selecting a specific trade-off for a given target.
The MicroPython Virtual Machine source code and/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM / RAM size) or for selecting a specific trade-off for a given target.
The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).
In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.
The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model ̶  floating-point numbers require heap allocation, 2.bits model “NaN Boxing”   ̶  floating numbers do not require heap allocation.
The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules/submodules
The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.
The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4
The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.
The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].
The MicroPython Virtual Machine shall raise an exception in case it is no more possible to allocate memory on the heap.
The MicroPython Virtual Machine shall raise an exception in case it is no more possible to allocate memory on the stack.
The MicroPython Virtual Machine source, configuration, tool chain and test bench files shall be maintained in configuration control.
Basic mathematical Library Test Suite shall be implemented in ISO C99 / C++11.
Basic mathematical Library Test Suite shall be reusable and shall not make use of commercial third party software.
Basic mathematical Library Test Suite shall work on both host platforms: on Windows and Linux.
Basic mathematical Library Test Suite shall support tests for all functions and macros of Basic mathematical Library in single (32bit) and double (64bit) floating point precision.
Basic mathematical Library Test Suite shall be designed to work as a stand-alone application.
Basic mathematical Library Test Suite shall be expandable, allowing the integration of new mathematical functions by configuration means and dedicated code source files.
Basic mathematical Library Test Suite shall allow user to select one or more functions for running a test.
Basic mathematical Library Test Suite shall allow the user to select one of the predefined test types before a test run.
Basic mathematical Library Test Suite shall allow the user to select one of the configured targets before a test run.
Basic mathematical Library Test Suite shall support the automatically build of the target-native binaries on the host machine for the functions selected for test, based on a user adapted build script for specific target.
Basic mathematical Library Test Suite shall execute the test on host and target using GDB as a common interface.
Basic mathematical Library Test Suite shall automatically export all results of the Test Suite Executable execution on a target into documents in order to provide the qualification evidence of the Basic mathematical Library.
Basic mathematical Library Test Suite shall not loose results from previous runs. Basic mathematical Library Test Suite shall archive the obtained test report along with platform information as a performed run results.
The archived results shall also contain configuration information previously set by the user in order to permit the reproducibility of the test. Remark: Will be archived, at least: test input files, produced and used binaries, intermediary and log files, result documents.
Basic mathematical Library Test Suite shall allow the execution of functional unit tests. Remark:  Unit tests are written in order to verify tested function requirements, domain limits, corner cases, etc.
Basic mathematical Library Test Suite shall build a specific report to present functional unit tests results after unit tests run. It will contain at minimum: - result status PASS/FAIL per test case - input, expected and obtained values per test case - summary PASS/FAIL  per function 
Basic mathematical Library Test Suite shall allow tests that adjust the value of the functions parameters by sweeping the parameter values through a user defined range.
Basic mathematical Library Test Suite shall allow tests that check mathematical properties of tested functions.
Basic mathematical Library Test Suite shall allow comparison of tests to help assessing numerical reproducibility of the results produced by the mathematical library, from one run to the next, either on the same or different machines for the same input data set.
Basic mathematical Library Test Suite shall generate a report to present numerical reproducibility results  which contains: input values, output values obtained on current run and on reference run; ULP, relative and absolute error calculated between the runs.
Basic mathematical Library Test Suite shall provide structural coverage information for execution of the unit tests .  special coverage report will be generated containing at minimum:  - code coverage % per test - code coverage % global per function - coverage summary
Basic mathematical Library Test Suite shall provide execution time measurements for each tested function.
Basic mathematical Library Test Suite shall provide in report file the execution time measurements after performance  / timing tests.
Basic mathematical Library Test Suite shall allow tests that check for accuracy (e.g. ULP error, absolute error and relative error).
The Basic mathematical Library Test Suite shall evaluate the accuracy of the tested library against a bit accurate reference library.
Basic mathematical Library Test Suite shall produce a report after accuracy tests. The reports will contain at minimum:  - Input data: Range of the parameters taken in consideration and step  - Reference values obtained with reference mathematical library - Output value obtained with Basic mathematical Library - Error information: ULP error, absolute error, relative error
Basic mathematical Library Test Suite application shall run on a standard x86_64 PC with Windows / Linux operating system, with a minimum of 4 GB RAM and at least an Intel i3 (or equivalent) processor.
Test Suite Executable executable size shall not exceed 1024 kB.
During tests execution, Basic mathematical Library Test Suite shall inform the user about the progress of the test being executed.
Basic mathematical Library Test Suite shall be able to handle large amount of data results in case of parameter sweeping tests, for example testing 106 input values in a test case.
Basic mathematical Library Test Suite shall use the following type of input files:  - configuration files in XML format  - test cases written in in XML format.
The Basic mathematical Library Test Suite application configuration file will contain at least: - Localization of toolchain used for Test Suite Executable compilation on the host machine; - Localization of libraries to be included in Test Suite Executable compilation for the target machine; - The target configuration
For each test execution, the Basic mathematical Library TS shall use as input a test configuration file which contains at least this information: - Name of the function(s) to be tested - Type of the test  - Tested values and expected values for single value tests - Range of parameter values for the tests that need sweeping the function parameter values  - Any other configuration parameter needed to run the tests.
The output of Basic mathematical Library Test Suite shall be:  - Details result files (ASConfiguration ItemI / csv format) describing inputs, outputs, expected values, etc - High level report documents (HTML, XML format) describing global information. Detail test report files in csv format contains: - Input values - Expected values - Obtained values - Errors (ULP, absolute, relative) - Execution time
High level test report documents in html/xml format contains:  - Target information - Basic mathematical Library information - Basic mathematical Library Test Suite and toolchain information - Name of the function tested - Description of the test type selected - Summarisation section containing information interpreting the results of the suite of tests. - Depending of type of the test, for each function may be provided several types of graphs, e.g. ULP, absolute and relative error vs argument value.
gdb shall be the software interface between Basic mathematical Library Test Suite and the target platforms. It will be used to execute the Test Suite Executable on the target.
Basic mathematical Library Test Suite shall allow running the tests in batch mode.
Basic mathematical Library Test Suite shall allow running the tests manually.
Test Suite Executable shall run as a minimum in Real-Time Executive for Multiprocessor Systems versions 4.8 – 4.11, on the target SPARC V8 Hardware (Hardware) , a LEON 2 (AT697E/F)  processor with Meiko FPU.
The host processors where Test Suite Executable shall execute are x64 architecture.
Test Suite Executable shall run under Real-Time Executive for Multiprocessor Systems versions 4.8 – 4.11, on the target SPARC V8 Hardware (Hardware), with LEON 4 using GR-CPConfiguration Item-LEON4-N2X platform.
Basic mathematical Library Test Suite shall not make use or depend on commercial third party software. If necessary, free and open source tools may be used integrated in the testing framework.
On target boards, Test Suite Executable shall be able to run under Real-Time Executive for Multiprocessor Systems Operating system, versions 4.8 – 4.11.Basic mathematical Library
Test Suite Executable shall be able to run under Window and Linux Operating systems.
Basic mathematical Library Test Suite development shall be compliant to the software standard European Cooperation for Space Standardization -EST-40C [AD 2] criticality category D and the necessary documentation shall be produced.
Test Suite Executable shall be portable on different platforms, at least between Intel, AMD, Sparc V8 based processors.
Basic mathematical Library Test Suite shall be developed compliant to the (tailored) software standard  European Cooperation for Space Standardization-Q-ST-80C [AD 3] criticality category D and the necessary documentation shall be produced.
The Basic mathematical Library Test Suite statement coverage (source code) metric achieved by validation/integration/unit tests shall be at least 70%.
The coding rules used for C++ development in Basic mathematical Library Test Suite shall follow the “Google C++ Style Guide ” defined at: https://google.github.io/styleguide/cppguide.html
The coding rules used for C development in Basic mathematical Library Test Suite shall follow the “The Power of Ten - Rules for Developing Safety Critical Cod ” defined at: http://spinroot.com/gerard/pdf/P10.pdf    
Basic mathematical Library Test Suite shall check the communication with the target (through GDB) by using checksums on transferred packets and it shall implement retry management.
Two logical repositories will be used for the configuration management activities:  x the development repository: this repository will contain and handle the version control of the complete project data as it is been developed. x the master repository: this repository will contain and handle the baselines of the Configuration Item as listed in the Configuration Item List.
The following data formats will be used for the Configuration Item produced for distribution and archiving:  x PDF for documents, x ZIP for source code files.     
The BTLS source files shall be accompanied by a makefile.
The Basic Library shall implement the following additional procedures:deg2rad Procedure returning the radians value of a provided degree valuerem2pi Procedure returning the provided value reduced to the range [+0,2π]
The Basic Library shall provide procedures for 32 bit (binary32) and 64 bit (binary64) precision floating-point datums.
The Basic Library shall consider all arguments and return values that represent an angle to be in radians unless otherwise specified. 
Thedeg2rad and deg2radf procedures shall return the radians value equal to the argument x given in degrees. 
Thedeg2rad and deg2radf procedures shall return Not a Number if the argument is Not a Number.
Thedeg2rad and deg2radf procedures shall return the value of the argument if the argument is ±0or±Inf.
The rem2pi and rem2pif procedures shall return the positive remainder of the argument xn-times divided by the value 2πsuch that:+0≤x−n∗2π≤2π
The rem2pi and rem2pif procedures shall return Not a Number if the argument is Not a Number.
The rem2pi and rem2pif procedures shall return the value of the argument if the argument is ±0.
The rem2pi and rem2pif procedures shall return Not a Number if the argument is ±Inf.
The sin and sinf procedures shall evaluate the sine of their argument x in radians. 
The sin and sinf procedures shall use a minimax polynomial for the calculation. 
The sin and sinf procedures shall return Not a Number if the argument is Not a Number.
The sin and sinf procedures shall return the value of the argument if the argument is ±0.
The sin and sinf procedures shall return Not a Number if x is ±Inf.
The asin and asinf procedures shall evaluate the arcsine of their argument xin the outputrange [-π2,π2] radians. 
The asin and asinf procedures shall use a rational approximation for the calculation. 
The asin and asinf procedures shall return Not a Number if the argument is Not a Number.
The asin and asinf procedures shall return the value of the argument if the argument is ±0.
The asin and asinf procedures shall return Not a Number if the argument is ±Inf.
The asin and asinf procedures shall return Not a Numbe rif the argument is not in the range [-1, 1]. 
The cos and cosf procedures shall evaluate the cosine of their argument x in radians. 
The cos and cosf procedures shall use a minimax polynomial for the calculation. 
The cos and cosf procedures shall return Not a Numberif the argument is Not a Number.
The cos and cosf procedures shall return 1.0 if the argument is ±0.
The cos and cosf procedures shall return Not a Number, if the argument is ±Inf.
The acos and acosf procedures shall evaluate the principal value of the arccosine of their argument xin the output range [0, π] radians. 
The acos and acosf procedures shall use a rational approximation for the calculation. 
The acos and acosf procedures shall return Not a Number, if the argument x is not in the range [-1,1]. 
The acos and acosf procedures shall return Not a Number if the argument is Not a Number.
The acos and acosf procedures shall return +0 if the argument is +1.
The acos and acosf procedures shall return Not a Number if the argument x is ±Inf.
The tan and tanf procedures shall evaluate the tangent of their argument x in radians. 
The tan and tanf procedures shall use a minimax polynomial for the calculation. 
The tan and tanf procedures shall return Not a Number if the argument is Not a Number.
The tan and tanf procedures shall return the value of the argument if the argument is ±0.
The tan and tanf procedures shall return Not a Number, if the argument is ±Inf.
The atan and atanf procedures shall calculate the arctangent of their argument x in the output range [-π2,π2] radians. 
The atan and atanf procedures shall use a minimax polynomial for the calculation. 
The atan and atanf procedures shall return Not a Number if the argument is Not a Number.
The atan and atanf procedures shall return the argument if the argument is ±0.
The atan and atanf procedures shall return ±π2 if the argument is ±Inf.
The atan2 and atan2f procedures shall calculate the arctangent of the division y/xof their arguments x and y in the output range [- π,π] radians. 
The atan2 and atan2f procedures shall use atan and atanf procedures. 
The atan2 and atan2f procedures shall return ± π, if the argument y is ±0 and the argument x < 0.
The atan2 and atan2f procedures shall return ±0, if the argument y is ±0 and the argument x > 0.
The atan2 and atan2f procedures shall return -π2, if the argument y is <0 and the argument x is ±0.
The atan2 and atan2f procedures shall return π2, if the argument y is > 0 and the argument x is ±0.
The atan2 and atan2f procedures shall return Not a Number if any argument is Not a Number.
The atan2 and atan2f procedures shall return ±π, if the argument y is ±0 and the argument x is -0.
The atan2 and atan2f procedures shall return ±0, if the argument y is ±0 and the argument x is +0.
The atan2 and atan2f procedures shall return ±π, if the argument ± y is finite and not 0, and the argument x is -Inf.
The atan2 and atan2f procedures shall return ±0, if the argument ± yis finite and not 0, and the argument x is +Inf.
The atan2 and atan2f procedures shall return ±π2, if the argument y is ±Inf and the argument x has a finite value. 
The atan2 and atan2f procedures shall return ±3π4, if the argument y is ± Infand the argument x is -Inf.
The atan2 and atan2f procedures shall return ±π4, if the argument y is ±Inf and the argument x is +Inf.
The sqrt and sqrtf procedures shall calculate the square root of their argument x.
The sqrt and sqrtf procedures shall return Not a Number, if the argument x < -0.
The sqrt and sqrtf procedures shall return Not a Number if the argument x is Not a Number.
The sqrt and sqrtf procedures shall return the argument if the argument x is ±0 or +Inf.
The sqrt and sqrtf procedures shall return Not a Number, if the argument x is -Inf.
The exp and expf procedures shall calculate the base eexponential value of their argument x.
The exp and expf procedures shall use a minimax polynomial for the calculation. 
The exp and expf procedures shall return Not a Number if the argument x is Not a Number.
The exp and expf procedures shall return 1 if the argument x is ±0.
The exp and expf procedures shall return +0 if the argument x is -Inf.
The exp and expf procedures shall return the argument if the argument x is +Inf.
The pow and powf procedures shall calculate the value of their argument x raised to the power of y.
The pow and powf procedures shall use a binary logarithm for the calculation. 
The pow and powf procedures shall return Not a Number if the argument x is < 0 and finite, and the argument y is a finite, non-integer value. 
The pow and powf procedures shall return ±Inf respectively if y is an odd integer, or +Inf if y is not an odd integer if the argument y is < 0 and x is ±0.
The pow and powf procedures shall return Not a Number if the argument y is Not a Number and x is not 1, or the argument x is Not a Number and y is not ±0.
The pow and powf procedures shall return ±0 respectively, if the argument x is ±0 and the argument y is an odd integer > 0. 
The pow and powf procedures shall return +0, if the argument x is ±0 and the argument y is >0 and not an odd integer. 
The pow and powf procedures shall return 1.0 if the argument x is +1.
The pow and powf procedures shall return 1.0 if the argument y is ±0.
The pow and powf procedures shall return 1.0 if the argument x is -1, and the argument y is ±Inf.
The pow and powf procedures shall return +Inf if |x|<1 and the argument y is -Inf.
The pow and powf procedures shall return +0, if |x|>1 and the argument y is-Inf.
The pow and powf procedures shall return +0, if |x|<1 and the argument y is +Inf.
The pow and powf procedures shall return +Inf, if |x|>1 and the argument y is +Inf.
The pow and powf procedures shall return -0, if the argument x is -Inf and the argument y is an odd integer < 0. 
The pow and powf procedures shall return +0, if the argument x is -Inf and the argument y is <0 and not an odd integer. 
The pow and powf procedures shall return -Inf, if the argument x is -Inf and the argument y is an odd integer > 0. 
The pow and powf procedures shall return +Inf, if the argument x is -Inf and the argument y is> 0 and not an odd integer. 
The pow and powf procedures shall return +0, if the argument x is +Inf and the argument y<0.
The pow and powf procedures shall return +Inf, if the argument x is+ Inf and the argument y>0.
The log and logf procedures shall calculate the natural logarithm of their argument x.
The log and logf procedures shall return -Inf if the argument x is ±0.
The log and logf procedures shall return Not a Number if the argument x is finite and less than 0 or x is -Inf.
The log and logf procedures shall return Not a Number, if the argument x is Not a Number.
The log and logf procedures shall return +0, if the argument x is 1.
The log and logf procedures shall return +Inf, if the argument x is +Inf.
The log10 and log10f procedures shall calculate the base 10 logarithm of their argument x.
The log10 and log10f procedures shall return -Inf if the argument x is ±0.
The log10 and log10f procedures shall return Not a Number if the argument x is finite and less than 0 or x is -Inf.
The log10 and log10f procedures shall return Not a Number, if the argument x is Not a Number.
The log10 and log10f procedures shall return +0, if the argument x is 1.
The log10 and log10f procedures shall return +Inf, if the argument x is +Inf.
The fabs and fabsf procedures shall calculate the absolute values of their argument x.
The fabs and fabsf procedures shall return Not a Number, if the argument x is Not a Number.
The fabs and fabsf procedures shall return +0, if the argument x is ±0.
The fabs and fabsf procedures shall return +Inf, if the argument x is ±Inf.
The round and roundf procedures shall round their argument x to the nearest integer value, rounding halfway cases away from zero. 
The round and roundf procedures shall return Not a Number, if the argument x is Not a Number.
The round and roundf procedures shall return the argument, if the argument x is ±0 or ±Inf.
The floor and floorf procedures shall calculate the largest integral value not greater than their argument x.
The floor and floorf procedures shall return Not a Number, if the argument x is Not a Number.
The floor and floorf procedures shall return the argument, if the argument x is ±0 or ±Inf.
The trunc and truncf procedures shall round their argument x to the integer value nearest to but no larger in magnitude than the argument. 
The trunc and truncf procedures shall return Not a Number, if the argument x is Not a Number.
The trunc and truncf procedures shall return the argument, if the argument x is ±0 or ±Inf.
The ceil and ceilf procedures shall compute the smallest integral value not less than argument x.
The ceil and ceilf procedures shall return Not a Number, if the argument x is Not a Number.
The ceil and ceilf procedures shall return the argument, if the argument x is ±0 or ±Inf.
The fmod and fmodf procedures shall calculate the floating-point remainder of the division of the argument x by the argument y.
The fmod and fmodf procedures shall return Not a Number, if any argument is Not a Number.
The fmod and fmodf procedures shall return Not a Number, if the argument y is 0.
The fmod and fmodf procedures shall return Not a Number, if the argument x is ±Inf. 
The fmod and fmodf procedures shall return ±0, if the argument x is ±0 and the argument y is not zero. 
The fmod and fmodf procedures shall return the argument x, if the argument x is not ± Inf and the argument y is ±Inf.
The modf and modff procedures shall compute the integral and fractional part of the argument x.
The modf and modff procedures shall return the fractional part of the argument x and write the integral part of the argument x to the pointer provided by the argument ∗iptr.
The modf and modff procedures shall return Not a Number and set the argument ∗iptr to Not a Number, if the argument x is Not a Number.
The modf and modff procedures shall return ±0 and set the argument ∗iptr to ±Inf, if the argument x is ±Inf.
The fmin and fmin fprocedures shall determine the minimum numeric value of the argument x and y.
The fmin and fminf procedures shall return Not a Number, if the arguments x and y are Not a Number.
The fmin and fminf procedures shall return the one argument if only the other argument is Not a Number.
The fmin and fminf procedures shall return the y argument if both arguments are zero. 
The fmax and fmaxf procedures shall determine the maximum numeric value of the argument x and y.
The fmax and fmaxf procedures shall return Not a Number, if the arguments x and y are Not a Number.
The fmax and fmaxf procedures shall return the one argument if only the other argument is Not a Number.
The fmax and fmaxf procedures shall return the y argument if both arguments are zero. 
The hypot and hypotf procedures shall compute the length of the hypotenuse of a right angled triangle with sides of length x and y.
The hypot and hypotf procedures shall return +Inf, if one of the arguments x or y is ±Inf.
The hypot and hypotf procedures shall return Not a Number, if one of the arguments x or y is Not a Number and the other is not ±Inf.
The isfinite procedure shall return a non-zero value if the argument x has a finite value and is neither Not a Number nor ±Inf.
The isinf procedure shall return a non-zero value if and only if the argument x is ±Inf.
The isnan procedure shall return a non-zero value if and only if the argument x is Not a Number.
The signbit procedure shall return a non-zero value if and only if the argument x is negative.
The copysign and copysignf procedures shall compute a new number with the magnitude of the argument x and the the sign of y.
The copysign and copysignf procedures shall return Not a Number if the argument x is Not a Number.
The execution time of all procedures shall be bounded. 
The execution time of all procedures shall be characterizable within subdomains which cover the complete domain of the procedure.
The Worst Case Execution Time of the procedures shall not deviate by more than 30% from the median execution times of the characterized ranges.
The Basic mathematical Library procedure results shall differ from theoretical results by less than 0.5 Units in the Last Place.
The Basic Library shall be compliant to IEEE 754-2008. 
The Basic Library shall be compatible with code auto-generated with Matlab R2016a SimulinkCoder.
The Basic Library shall provide best practices within the Software User Manual to produce Ada wrappers to enable the use of the library from Ada83 and Ada95. 
The Basic Library shall provide best practices within the Software User Manual to produce C-MEX function wrappers, to enable the use of the Basic Library in Matlab and Simulink Matlab function blocks. 
The Basic Library shall provide best practices within the Software User Manual to produce S-function wrappers,to enable the use of the Basic Library in Simulink. 
The Basic Library shall run on x86-64 and SPARC V8 processor architectures. 
The Basic Library shall contribute less than 100kB to the size of the final On-Board Software executable. 
For the Basic Library it shall be selectable for which processor architecture it will be compiled. 
For the Basic Library it shall be configurable which procedures of the library will be included inthe linking step. 
The Basic Library procedures shall be reentrant and thread-safe. 
The Basic Library design shall define the behavior of the procedures in a tabular format, presenting the parameter domain decomposition and the corresponding output. 
The Basic Library design shall justify every modification to be carried out on the reused library.
The Basic Library shall be implemented in ISO C99. 
The Basic Library shall be compliant to the math.h definitions as per ISO C99 standard [RD03].
The Basic Library shall not provide error handling with the errnoglobal variable.
The Basic Library shall be compileable with GNU C Compiler version 4.2.1 with Binutils version 2.18. 
The Basic Library shall be compatible to Real-Time Executive for Multiprocessor Systems Operating System version 4.8 distributed by Edisoft. 
The Basic Library shall not use Floating Point Unit )builtin functions for elementary math function evaluation. 
The Basic Library shall not rely on the presence of the Fused Multiply-Add (Fused Multiply-Add) operation for algorithm optimization. 
The Basic Library shall be able to convert to a modus that mirrors the Floating Point Unit’s behaviour regarding subnormal numbers in case the Floating Point Unit does not handle subnormal numbers the same as normal numbers.
The Basic Library source shall be compliant to the mandatory and required rules depicted in MISRA C:2012 [RD06]. 
The Basic Library shall provide a justification for not respected required rules in MISRA C:2012[RD06]. 
The Basic Library shall comply to the mandatory metrics provided by European Cooperation for Space Standardization-HB-Q-80 [RD05] with their proposed targets. 
The Basic Library shall comply to required metric ‘User documentation completeness’ proposedby European Cooperation for Space Standardization-HB-Q-80 [RD05] with their proposed targets. 
The Basic Library shall return the exact same value whenever a procedure is called multiple times with the same argument(s). 
The Basic Library shall never cause either CPU or Floating Point Unit to stop. 
The Basic Library source shall be delivered as a collection of C source files.
The Basic Library shall be delivered with a GNU Make makefile and associated scripts to configure, build and install the Basic Library. 
Each modified or newly created file, be it source or documentation, of the Basic Library shall contain a header including the European Space Agency copyright notice: 20xx
The Basic Library shall use 32bit and 64bit IEEE 754 [RD01] floating-point datums as well as 32bit integers to exchange data. 
The Basic mathematical Library shall run on Scalable Processor Architecture V8 and x86-64processor architectures without halting the processor.
The Basic mathematical Library shall be written in ISO/IEC 9899.
The Basic mathematical Library shall be compatible with the Real-Time Executive for Multiprocessor Systems Operating System.
The Basic mathematical Library shall be IEEE 754-2008 compliant.
The Basic mathematical Library shall be European Cooperation for Space Standardization category B compliant.
The Basic mathematical Library shall be Motor Industry Software Reliability Asociation-C:2012 compliant.
The Basic mathematical Library shall be compatible with the GNU C Compiler compiler and with Binutils.
The Basic mathematical Library shall provide best practices to develop an interface to access allits functionality from Matlab.
The Basic mathematical Library shall provide best practices to develop an interface to access allits functionality from Simulink.
The Basic mathematical Library shall provide best practices to develop C-MEX function wrappers for all its procedures.
The Basic mathematical Library shall provide best practices to develop S-function wrappers for all its procedures.
The Basic mathematical Library shall be compatible with source code auto-generated with the Simulink Coder.
The Basic mathematical Library shall provide best practices to develop an interface to access allits functionality from Ada.
The Basic mathematical Library shall obtain numerically reproducible results on x86-64 and Scalable Processor Architecture V8 processors.
The Basic mathematical Library shall be tested on a LEON2, a LEON4, and a x86-64 platformfor its reproducibility.
The Basic mathematical Library shall provide the following procedures: sin, cos, tan, asin, acos, atan, atan2, floor, ceil, round, trunc, hypot, sqrt, fmod, remainder, fabs, signbit, modf, exp, pow, log10, log, fmin, fmax, isfinite, isinf, isnan, and copy-sign.
The Basic mathematical Library shall be compatible to math.h regarding the procedures definedby ISO/IEC 9899.
The Basic mathematical Library shall provide float (32 bit floating-point) and double (64 bitfloating-point) versions of the procedures.
The Basic mathematical Library shall provide the following constants as defined by the POIX standard: M_E, M_LOG2E, M_LOG10E, M_LN2, M_LN10, M_PI, M_PI_2, M_PI_4, M_1_PI, M_2_PI, M_2_SQRTPI, M_SQRT2, M_SQRT1_2, MAXFLOAT, HUGE_VAL, HUGE_VALF, INFIN-ITY, NAN.
The Basic mathematical Library shall provide a procedure to convert angles in degrees to radians.
The Basic mathematical Library shall provide a procedure to convert an angle to an equivalentone in the range [0,2π].
The Basic mathematical Library shall not use Floating Point Unit built in functions for elementary math function evaluation.
The Basic mathematical Library shall not rely on the presence of the Fused Multiply-Addoperation for algorithm optimization.
The Basic mathematical Library shall have a configurable modus to handle denormal arguments as zero.
The Basic mathematical Library shall have a configurable modus to flush denormal computation results to zero.
The Basic mathematical Library shall not use the errno global variable for error handling.
The Basic mathematical Library procedures shall behave as defined by the POIX standard for special cases i.e. regarding arguments and outputs involving Not a Number, infinities, and ±0.
The Basic mathematical Library design shall define the behavior of the procedures in a tabular format, presenting the parameter domain decomposition and the corresponding output.
The Basic mathematical Library procedures shall be reentrant and thread-safe.
The Basic mathematical Library procedures shall have a bounded Worst Case Execution Time.
The Basic mathematical Library procedures shall have a well defined Worst Case Execution Time over the complete argument domain.
The Basic mathematical Library shall have a memory footprint at most 30% bigger than the libm in Newlib.
The Basic mathematical Library Test Suite shall perform execution time tests, analyzing the minimum, maximum, average, and median execution timesof the procedures.
The Basic mathematical Library Test Suite shall perform memory usage tests, analyzing the memoryusage of the Basic mathematical Library procedures.
The Basic mathematical Library design shall document every modification applied to the reused library.
The Basic mathematical Library Test Suite shall be European Cooperation for Space Standardization category D compliant.
The execution of the Basic mathematical Library Test Suite shall controlled from Windows or GNU/Linux host systems.
The Basic mathematical Library Test Suite shall have a set of unambiguous input values for testing the Basic mathematical Library in the form of defined 32 bit and 64 bit floating-point datums.
The Basic mathematical Library Test Suite shall measure the differences in accuracy in Unit in the Last Places between the results of the Basic mathematical Library procedures and the reference output values.
The Basic mathematical Library Test Suite shall have a definition of Unit in the Last Place and how two floating-point numbers differ in Unit in the Last Places.
The Basic mathematical Library procedures shall obtain results with a maximum difference of 0.5 Unit in the Last Places to the actual value of the mathematical function they implement.
The test cases of the Basic mathematical Library Test Suite shall have reference output values that have been produced with an arbitrary precision mathematical software set to a higher precision than 64 bits.
The reliability of the arbitrary precision mathematical software used to produce the reference output values to test the Basic mathematical Library shall be assessed and justified.
The Basic mathematical Library Test Suite shall run in batch and manual modus.
The Basic mathematical Library Test Suite shall have no dependencies to commercial third party software.
The Basic mathematical Library Test Suite shall use GNU Debugger as the main interface to the Hardware execution platforms.
The Basic mathematical Library Test Suite produce test result reports on the target platforms and get them back to the host system.
The Basic mathematical Library Test Suite shall gather statement coverage data while running the test suite on target and on x86-6.
The Basic mathematical Library Test Suite shall provide loop and Multiple Condition Decision Coverage coverage data obtained while developing the test suite.
The Basic mathematical Library Test Suite shall analyze manually the path coverage of procedures with a very high cyclomatic complexity.
The software product shall provide an Application Programming Interface.
The system shall provide configuration options to the application to set configurable systemparameters at link time.
Each non-default directive attribute constant shall be a power of two representable as aninteger of type rtems_attribute.
Each default directive attribute constant shall have a value of zero.
The value of macro Real-Time Executive for Multiprocessor Systems_DEFAULT_ATTRIBUTES shall be equal to the value of expression Real-Time Executive for Multiprocessor Systems_FIFO | Real-Time Executive for Multiprocessor Systems_LOCAL.
The Real-Time Executive for Multiprocessor Systems_SEMAPHORE_CLASS constant shall be equal to the bitwise OR of Real-Time Executive for Multiprocessor Systems_BINARY_SEMAPHORE, Real-Time Executive for Multiprocessor Systems_COUNTING_SEMAPHORE, andReal-Time Executive for Multiprocessor Systems_SIMPLE_BINARY_SEMAPHORE.
The non-default directive attribute constants shall have unique values.
When the argument _alignment is a positive power of two integer, and argument _valueis a positive or 0 integer, the macro Real-Time Executive for Multiprocessor Systems_ALIGN_DOWN shall result in a side-effect free formula calculating an integer which is the greatest whole-number multiple of_alignment which is smaller or equal _value.
When the argument _alignment is a positive power of two integer, and argument _value isa positive or 0 integer, the macro Real-Time Executive for Multiprocessor Systems_ALIGN_UP shall result in a side-effect free formula calculating an integer which is the smallest whole-number multiple of_alignment which is greater or equal _value.
When the argument _alignment is a positive power of two integer, and the macro Real-Time Executive for Multiprocessor Systems_ALIGNED is used on a none-static variable or structure field, and the used linker supports alignments of the size given by the _alignment argument, and the code is compiled with the GNU C compiler, the macro shall specify a minimum alignment for the variable or structure field, measured in bytes.
When the code is compiled with a C compiler and the __STDC_VERSION__ symbol is defined with version 201112L or higher or the code is compiled with a C++ compiler and the __cplusplus symbol is defined with version 201103L or higher, and the argument _type_nameis a type, and the argument _type_name is not a function type, and the argument _type_name is a complete type, the macro Real-Time Executive for Multiprocessor Systems_ALIGNOF shall result in the alignment requirement in bytes required for any instance of the type.
When the code is compiled with a C compiler and the __STDC_VERSION__ symbol is defined with version 201112L or higher or the code is compiled with a C++ compiler and the __cplusplus symbol is defined with version 201103L or higher, the macro Real-Time Executive for Multiprocessor Systems_ALIGNOF shall not evaluate its argument _type_name .
When the code is compiled with a C compiler and the __STDC_VERSION__ symbol is defined with version 201112L or higher or the code is compiled with a C++ compiler and the __cplusplus symbol is defined with version 201103L or higher, when the argument_type_name is an array type with none constant size expression, the macro Real-Time Executive for Multiprocessor Systems_ALIGNOF shall not evaluate the size expression.
The macro Real-Time Executive for Multiprocessor Systems_ALIGNOF shall result in an constant integer of type size_t.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_ALLOC_ALIGN macro is used as last part of a function declaration, and _index is a constant number referring to an argument of that function (counting of arguments starts at 1 from the left), and the argument with that number is an integral value of a power of two, and the declared function returns a pointer to memory which starts at an integral multiple of the value provided by the function argument number _index , the macro shall cause the compiler to use the information of the alignment of the returned memory in its pointer analysis.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_ALLOC_SIZE macro is used as last part of a function declaration, and _index is a constant number referring to an argument of that function (counting of arguments starts at 1 from the left), and the declared function returns a pointer to memory with the size in bytes provided by the function argument number _index , the macro shall cause the compiler to improve the correctness of__builtin_object_sizepointer analysis.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_ALLOC_SIZE_2 macro is used as last part of a function declaration, and _count_index as well as _size_index are constant numbers referring to two different arguments of that function (counting of arguments starts at 1 from the left), and the declared function returns a pointer to memory with the size in bytes provided by the multiplication of the function arguments number_count_index and_size_index , the macro shall cause the compiler to improve the correct-ness of__builtin_object_sizepointer analysis.
When the argument _index evaluates to an value o f a C one-dimensional array type, and the evaluation of that argument has no side effects, the macro Real-Time Executive for Multiprocessor Systems_ARRAY_SIZE shall result in the number of elements with which that array has been defined.
The macro Real-Time Executive for Multiprocessor Systems_COMPILER_DEPRECATED_ATTRIBUTE shall have exactly the same effect as the macro Real-Time Executive for Multiprocessor Systems_DEPRECATED.
When the code is compiled with the GNU C compiler, the Real-Time Executive for Multiprocessor Systems_COMPILER_MEMORY_BARRIER macro shall realize a Full Software MemoryBarrier at the place in the code where it occurs.
The macro Real-Time Executive for Multiprocessor Systems_COMPILER_NO_RETURN_ATTRIBUTE shall have exactly the same effectas the macro Real-Time Executive for Multiprocessor Systems_NO_RETURN.
The macro Real-Time Executive for Multiprocessor Systems_COMPILER_PACKED_ATTRIBUTE shall have exactly the same effect as the macro Real-Time Executive for Multiprocessor Systems_PACKED.
The macro Real-Time Executive for Multiprocessor Systems_COMPILER_PURE_ATTRIBUTE shall have exactly the same effect as the macro Real-Time Executive for Multiprocessor Systems_PURE.
The macro Real-Time Executive for Multiprocessor Systems_COMPILER_UNUSED_ATTRIBUTE shall have exactly the same effect as the macro Real-Time Executive for Multiprocessor Systems_UNUSED.
When neither argument is a call of the macro Real-Time Executive for Multiprocessor Systems_CONCAT itself, the macro shall result in both argument values concatenated textually unaltered in the order they are provided.
The macro Real-Time Executive for Multiprocessor Systems_CONCAT shall result in only those characters which also appear in its argument values.
The macro Real-Time Executive for Multiprocessor Systems_CONCAT shall make its result subject to C pre-processor operations.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_CONST macro is attached to a function declaration or definition, and the return value of that function is not affected by changes to the observable state of the program and that function has no observable effects on such state other than to return a value, the Real-Time Executive for Multiprocessor Systems_CONST macro shall permit the compiler to replace subsequent calls to the function with the same argument values bythe result of the first call.
When argument _m points to a member field of a structure or union or C++ class, and argument _type is the C type of this structure or union or C++ class, and argument _member_name is the name of this member field, the Real-Time Executive for Multiprocessor Systems_CONTAINER_OF macro shall result in a pointer to the start address of the structure or union or C++ class.
When the macro Real-Time Executive for Multiprocessor Systems_DECLARE_GLOBAL_SYMBOL appears at file scope, and argument_name after undergoing C pre-processor substitutions results in a valid C identifier name, and this identifier name is not yet defined at file scope, the macro Real-Time Executive for Multiprocessor Systems_DECLARE_GLOBAL_SYMBOL shall apply all possible C pre-processor substitutions to its argument value before it results in code which declares a global symbol with the respective name.
When_type is a non-const pointer type, and _var is a pointer to a value of const type, and the types of_type and_var are compatible in the sense of C, the macro Real-Time Executive for Multiprocessor Systems_DECONST shall result in an expression which returns a pointer of type _type pointing to the same address as_var.
When the macro Real-Time Executive for Multiprocessor Systems_DEFINE_GLOBAL_SYMBOL appears at file scope, and argument_name after undergoing C pre-processor substitutions results in a valid C identifier name, and this identifier name is not yet defined at file scope, and argument _value after undergoing C pre-processor substitutions results in a valid assembler integer value, the macro Real-Time Executive for Multiprocessor Systems_DEFINE_GLOBAL_SYMBOL shall apply all possible C pre-processor substitutions to its argument values before it results in assembler code which defines a global symbol with the respective name and value.
The macro Real-Time Executive for Multiprocessor Systems_DEFINE_GLOBAL_SYMBOL shall define a global symbol of void pointertype with the value being an address.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_DEPRECATED macro is used as last part of a function declaration or type declaration or variable declaration or variable definition, the macro shall cause the compiler to issue a warning message when it encounters a use of the function, type or variable.
When_type is a non-const non-volatile pointer type, and _var is a pointer to a value of const volatile type, and the types of _type and_var are compatible in the sense of C, the macro Real-Time Executive for Multiprocessor Systems_DEQUALIFY shall result in an expression which returns a pointer of type _typepointing to the same address as _var.
When_type is a non-volatile pointer type, and _var is a pointer to a value of volatile type, and the types of _type and_var are compatible in the sense of C, the macro Real-Time Executive for Multiprocessor Systems_DEVOLATILE shall result in an expression which returns a pointer of type _type pointing to the sameaddress as _var.
The macro Real-Time Executive for Multiprocessor Systems_EXPAND shall apply all possible C pre-processor substitutions to its argument value before it results in the substituted value.
The macro FALSE shall result in the text 0.
When the code is compiled with the GNU C compiler, and argument _t_lhs is a union or structure, and _m_lhs is a member of _t_lhs , and argument _t_rhs is a union or structure,and_m_rhs is a member of _t_rhs, the Real-Time Executive for Multiprocessor Systems_HAVE_MEMBER_SAME_TYPE macro shall evaluate to the integer values 1 or 0 depending on whether the types of the members _m_lhsand_m_rhs are compatible in the sense of C.
The Real-Time Executive for Multiprocessor Systems_INLINE_ROUTINE macro shall evaluate to the keywords static inline or static __inline__ which ever variant is available to the used compiler.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_MALLOCLIKE macro is used as last part of a function declaration or is attached to a function definition, and the function returns a pointer to memory, and this pointer cannot be an alias of any other pointer valid when the function returns, and no pointers to valid objects occur in any storage addressed by that pointer, and the function returns non-NULL in more than 50% of the cases, the macro shall cause the compiler to use this information for optimization.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_NO_INLINE macro is used as last part of a function declaration or is attached to a function definition, and the function has side-effects, the macro shall prevent the compiler from inlining this function.
When the code is compiled with the GNU C compiler starting at version 2.5 or the __cplusplus symbol is defined with version 201103L or higher or the __STDC_VERSION__ symbol is defined with version 201112L or higher, and the Real-Time Executive for Multiprocessor Systems_NO_RETURN macro is used as first part of a function declaration or definition, the Real-Time Executive for Multiprocessor Systems_NO_RETURN macro shall inform the compiler that this function does not return when called.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_SECTION macro is attached to a global variable definition, and the file format used supports arbitrary sections, the macro shall cause the compiler to store the variable in a section where its value is not initialized during initial start up.
When the code is compiled with the GNU C compiler, and argument _var is an automatic variable or function argument, and the value of that variable or function argument is of a type which fits into a register, the Real-Time Executive for Multiprocessor Systems_OBFUSCATE_VARIABLE macro shall prevent the compiler from performing optimizations based on the variable value.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_PACKED macro is used as last part of a structure member declaration, and the aligned attribute or Real-Time Executive for Multiprocessor Systems_ALIGNED macro is not used on this structure member, the Real-Time Executive for Multiprocessor Systems_PACKED macro shall cause the structure member to be aligned at one bit for a bit-field member and one byte otherwise.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_PACKED macro is attached to a struct, union, or C++ class type definition, and the aligned attribute or Real-Time Executive for Multiprocessor Systems_ALIGNED macro is not used on the struct, union, or C++ class type definition or any member thereof, the Real-Time Executive for Multiprocessor Systems_PACKED macro shall cause all structure, union, or classmembers to be aligned at one bit for a bit-field member and one byte otherwise.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_PACKED macro is attached to a enum type definition, the Real-Time Executive for Multiprocessor Systems_PACKED macro shall cause the use of the smallest integral type to represent the values of the enum.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_PREDICT_FALSE macro is used as a conditional in if-expressions and loop expressions, and _exp after undergoing all possible C pre-processor substitutions is an integral expression, the macro shall cause the compiler to assume that by the percentage of cases defined by builtin-expect-probability the expression evaluates to 0.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_PREDICT_TRUE macro is used as a conditional in if-expressions and loop expressions, and _exp after undergoing all possible C pre-processor substitutions is an integral expression, the macro shall cause the compiler to assume that by the percentage of cases defined by builtin-expect-probability the expression evaluates to 1.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_PRINTFLIKE macro is used as last part of a function declaration or prefixes a function definition, and _format_pos is a constant number referring to an argument of that function, and the function argument number_format_pos is a printf -format string, and the function argument _ap_pos is 0, the macro shall cause the compiler to use this information for checking the format string.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_PURE macro is attached to a function declaration or definition, and the function has no observable effects on the state of the program other than to return a value, the Real-Time Executive for Multiprocessor Systems_PURE macro shall permit the compiler to replace subsequent calls to the function with the same argument values by the result of the first call provided the state of the program observable by that function does not change in between two calls.
When the code is compiled with the GNU C compiler, the Real-Time Executive for Multiprocessor Systems_RETURN_ADDRESS macro shall evaluate to the code __builtin_return_address( 0 ) .
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_SECTION macro is attached to a function declaration or definition or a global variable definition, and the argument_section after applying all possible C pre-processor substitutions to its value is a C string containing valid linker section name, and the file format used supports arbitary sections, the macro shall cause the compiler to store the function or variable in a section named like the result of the pre-processor substitutions on its argument _section .
When the macro __COVERITY__ is defined, the macro Real-Time Executive for Multiprocessor Systems_STATIC_ANALYSIS shall be defined.
When the macro __COVERITY__ is not defined, the macro Real-Time Executive for Multiprocessor Systems_STATIC_ANALYSIS shall be not defined.
When the argument _cond after applying all possible C pre-processor substitutions to its value results in a valid C expression of integral type, and this expression can be evaluated at compile time, and the argument _msg which may or may not undergo C pre-processor substitutions results into a valid C identifier, the Real-Time Executive for Multiprocessor Systems_STATIC_ASSERT macro shall cause the compiler to produce a compilation error if the expression resulting from _cond evaluates to 0.
The Real-Time Executive for Multiprocessor Systems_STRING macro shall result in a string formed by the C pre-processor #operator placed before the formal parameter.
The macro TRUE shall result in the text 1.
When the argument value of _level consists of a sequence of i* and the type of the other argument has i or less than i nested pointers (for example * for a pointer to int, ** for apointer to a pointer of int, *** for a pointer to a pointer to a pointer to int), and_target is either a pointer type (possibly with qualifiers) or an expression of such a pointer type, the macro Real-Time Executive for Multiprocessor Systems_TYPEOF_REFX shall result in a type expression which is the type of argument_target with the given number of pointers removed.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_UNREACHABLE macro is placed in a part of the code which control ﬂow can under no circumstances ever reach, the macro shall inform the compiler that this place in code cannot be reached.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_UNUSED macro is attached to a function definition, the Real-Time Executive for Multiprocessor Systems_UNUSED macro shall prevent the compiler from emitting a warning if this function is not used.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_UNUSED macro is appended to a label in this form: <label>: Real-Time Executive for Multiprocessor Systems_UNUSED; , the Real-Time Executive for Multiprocessor Systems_UNUSED macro shall prevent the compiler from emitting a warning if this label is not used.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_UNUSED macro is attached to a type (including a union or a struct), the Real-Time Executive for Multiprocessor Systems_UNUSED macro shall prevent the compiler from emitting a warning if variables of this type are not used.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_UNUSED macro is attached to a variable definition, the Real-Time Executive for Multiprocessor Systems_UNUSED macro shall prevent the compiler from emitting a warning if this variable is not used.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_USED is macro attached to a function or static variable definition, the macro shall cause the compiler to emit the function implementation or variable storage even if there is no reference from C code to the function or variable.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_WARN_UNUSED_RESULT macro is used as last part of a function declaration or attached to a function definition, and that function has a return type other than void ,and the returned value is not used, the macro shall cause the compiler to show a compilerwarning.
When the code is compiled with the GNU C compiler, and the produced target file format is ELF or a.out, and the Real-Time Executive for Multiprocessor Systems_WEAK macro is part of a function definition at global scopeor variable definition at global scope, and there is no other symbol at global scope with the same name as the one of the above mentioned function or variable, the macro shall have no observable effect.
When the code is compiled with the GNU C compiler, and the produced target file format is ELF or a.out, and the Real-Time Executive for Multiprocessor Systems_WEAK macro is part of a function definition at global scope or variable definition at global scope, and there is another symbol at global scope with the same name as the above mentioned function or variable, and this other symbol is not defined with the Real-Time Executive for Multiprocessor Systems_WEAK macro or otherwise defined or declared weak, and both functions or variables have the same type, and in case of variables both variables have the same alignment and storage size, the macro shall cause the code to behave as if the function or variable defined with the Real-Time Executive for Multiprocessor Systems_WEAK macro does not exist.  
When the code is compiled with the GNU C compiler, and the produced target file format is ELF or a.out, and argument _target is a name of a function, and the macro Real-Time Executive for Multiprocessor Systems_WEAK_ALIAS call is in the same compilation unit as the function, and the macro is not used in block scope, and the macro is used in this form: <return-type>newname([argument-type-list]) Real-Time Executive for Multiprocessor Systems_WEAK_ALIAS(oldname);, and the <return-type> and argument-type-list match the signature of the function oldname , and there is no other function symbol at global scope with the same name as newname , the Real-Time Executive for Multiprocessor Systems_WEAK_ALIAS macroshall cause the compiler to create an additional name ( newname in the syntax) for the function given as argument _target .
The macro Real-Time Executive for Multiprocessor Systems_XCONCAT shall apply all possible C pre-processor substitutions to its argument values before it concatenates the resulting values.
The macro Real-Time Executive for Multiprocessor Systems_XCONCAT shall result in the substituted argument values textually concatenated in the order _xleft and_yright.
The macro Real-Time Executive for Multiprocessor Systems_XCONCAT shall result in only those characters which also appear in its argument values after applying all possible C pre-processor substitutions to them.
The macro Real-Time Executive for Multiprocessor Systems_XCONCAT shall make its result subject to C pre-processor substitutions.
The macro Real-Time Executive for Multiprocessor Systems_XSTRING shall apply all possible C pre-processor substitutions to its argument values before the result of this substitution is converted to a string formed by the C pre-processor #operator and the macro results in this string.
When the code is compiled with the GNU C compiler, and the Real-Time Executive for Multiprocessor Systems_ZERO_LENGTH_ARRAY macro is used as element count of an array declaration, and that array declaration is the last member of a struct that is otherwise non-empty ,and that structure is never used as member of another structure or array, the macro shall cause the compiler to layout the structure as if the array had an element count of one but to reduce the total size of the structure by the size of that one array element.
The rtems_clock_get_ticks_per_second function shall return the number of clock ticks per second which is defined indirectly by the CONFIGURE_MICROSECONDS_PER_TICK configuration option.
The rtems_clock_get_ticks_since_boot function shall return the number of clock ticks since a point in time during the system initialization or the last overﬂow of the clock tick counter.
Each non-default task mode constant shall be a power of two representable as an integer of type rtems_mode.
Each default task mode constant shall have a value of zero.
Each task mode mask constant except Real-Time Executive for Multiprocessor Systems_INTERRUPT_MASK shall be a power of two representable as an integer of type rtems_mode.
The bitwise and of a task mode mask constant and Real-Time Executive for Multiprocessor Systems_ALL_MODE_MASKS shall be equal to the task mode mask constant.
The task mode mask constants and 0xff shall have unique values.
The non-default task mode constants shall have unique values.
Each non-default directive option constant shall be a power of two representable as an integer of type rtems_option.
Each default directive option constant shall have a value of zero.
The value of macro Real-Time Executive for Multiprocessor Systems_DEFAULT_OPTIONS shall be equal to the value of expression Real-Time Executive for Multiprocessor Systems_WAIT .
The non-default directive option constants shall have unique values.
The application configuration option shall disable the system initialization of filesystems.
The application configuration option shall disable the system initialization of the Clock Driver.
The application configuration option shall enable the initialization of the Clock Driver during system initialization.
Where CONFIGURE_DISABLE_BSP_SETTINGS is not defined by the application, where BSP_INITIAL_EXTENSION is defined by the BSP, when the application configuration is initialized, the extension set defined by BSP_INITIAL_EXTENSION shall be registered in the initialextension sets.
Where CONFIGURE_DISABLE_BSP_SETTINGS is not defined by the application, where CONFIGURE_BSP_PREREQUISITE_DRIVERS is defined by the BSP, when the application configuration is initialized, the device driver entry points defined by CONFIG-URE_BSP_PREREQUISITE_DRIVERS shall be registered in the Device Driver Table.
The application configuration option shall disable the use of BSP-provided default values for application configuration options.
The application configuration option shall disable the thread-specific Newlib reentrancy support.
The application configuration option shall define the IDLE task body .
The application configuration option shall indicate that the user has configured no user initialization tasks or threads and that the user-provided IDLE task will perform applicationinitialization and then transform itself into an IDLE task.
The application configuration option shall define the task stack size for an IDLE task.
While CONFIGURE_INIT is defined, while rtems/confdefs.h is included in a translation unit after the definition of CONFIGURE_INIT, when the translation unit is preprocessed and compiled, the system settings defined by present application configuration options shall be statically allocated and initialized.
The application configuration option shall define the task argument of the Classic Application Programming Interface initialization task.
The application configuration option shall define the task attributes of the Classic Application Programming Interface initialization task.
The application configuration option shall define the task storage size of the Classic Application Programming Interface initialization task.
The application configuration option shall define the entry point of the Classic Application Programming Interface initialization task.
The application configuration option shall define the initial execution mode of the Classic Application Programming Interface initialization task.
The application configuration option shall define the name of the Classic Application Programming Interface initialization task.
The application configuration option shall define the initial priority of the Classic Application Programming Interface initialization task.
The application configuration option shall add the value to the initial extension sets.
The application configuration option shall define the size of an interrupt stack in bytes.
Where CONFIGURE_DISABLE_BSP_SETTINGS is not defined by the application, where CON-FIGURE_MALLOC_BSP_SUPPORTS_SBRK is defined by the BSP, when the application configuration is initialized, not all memory shall made available to the C Program Heap immediately at system initialization time.
The application configuration option shall define the maximum number of Classic Application Programming Interface Barriers that can be concurrently active.
The application configuration option shall define the maximum number of file like objects that can be concurrently open.
The application configuration option shall define the maximum number of Classic Application Programming Interface Message Queues that can be concurrently active.
The application configuration option shall define the maximum number of Classic Application Programming Interface Partitions that can be concurrently active.
The application configuration option shall define the maximum number of Classic Application Programming Interface Periods that can be concurrently active.
The application configuration option shall define the maximum numeric priority of tasks.
The application configuration option shall define the maximum number of processors an application intends to use.
The application configuration option shall define the maximum number of Classic Application Programming InterfaceSemaphore that can be concurrently active.
The application configuration option shall define the maximum number of Classic Application Programming Interface Tasks that can be concurrently active.
The application configuration option shall define the maximum thread-local storage size in bytes.
The application configuration option shall define the maximum number of Classic Application Programming Interface Timers that can be concurrently active.
The application configuration option shall define the maximum number of Classic Application Programming Interface UserExtensions that can be concurrently active.
The application configuration option shall define the length of time in microseconds between clock ticks (clock tick quantum).
The application configuration option shall define the minimum stack size in bytes for every user task or thread in the system.
The application configuration option shall define the minimum count of Classic Application Programming Interface Tasks which are constructed by rtems_task_construct.
The application configuration option shall enable that exactly one Classic Application Programming Interface initializationtask is configured.
While the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN() macro is used to define an entry of a CONFIGURE_SCHEDULER_ASSIGNMENTS application configuration option value, the attributes defined by the second parameter shall define the scheduler assignment attributes for the processor associated with the entry .
While the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN_NO_SCHEDULER define is used to define an entry of a CONFIGURE_SCHEDULER_ASSIGNMENTS application configuration option value, the processor associated with the entry shall not have a scheduler assigned.
While the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN_PROCESSOR_MANDATORY define is used as the second parameter in the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN() macro in an entry of a CONFIGURE_SCHEDULER_ASSIGNMENTS application configuration option value, the presence of the processor associated with the entry in the target shall be mandatory.
While the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN_PROCESSOR_OPTIONAL define is used as the second parameter in the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN() macro in an entry of a CONFIG-URE_SCHEDULER_ASSIGNMENTS application configuration option value, the presence of the processor associated with the entry in the target shall be optional.
The application configuration option shall define the initial scheduler to processor assignments.
The application configuration option shall make the Earliest Deadline First Symmetric Multiprocessing Scheduler algorithm available to the application.
The application configuration option shall define the name of the default scheduler.
The application configuration option shall make the Deterministic Priority Scheduler algorithm available to the application.
The application configuration option shall define the entries of the table of configured schedulers.
The application configuration option shall define the stack allocator allocate handler.
The application configuration option shall define the stack allocator allocate handler for an IDLE task.
The application configuration option shall define the stack allocator deallocate handler.
The application configuration option shall indicate that the task stack allocator does not use the Real-Time Executive for Multiprocessor Systems Workspace.
The application configuration option shall define the length of the timeslice quantum for each task in clock ticks.
The TN0018_FIX macro shall provide an instruction sequence for Workaround #1 to be placed immediatly before a jumpl followed by rett pair.
The TN0018_WAIT_IFLUSH macro shall ﬂush the instruction cache.
The TN0018_WRITE_PSR macro shall write the source register to register %psr.
While the system is initialized, if the data cache snooping is disabled on the boot processor, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_BSP fatal source and the LEON3_FATAL_INVALID_CACHE_CONFIG_BOOT_PROCESSOR fatal code. 
While the system is initialized, if the data cache snooping is disabled on a secondary processor, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_BSP fatal source and the LEON3_FATAL_INVALID_CACHE_CONFIG_SECONDARY_PROCESSOR fatal code.
If the installation of the clock interrupt entry fails, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_BSP fatal source and the LEON3_FATAL_CLOCK_INITIALIZATION fatal code.
While the fatal source is not Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing or the fatal code is not Symmetric Multiprocessing_SHUTDOWN_RESPONSE, the bsp_fatal_extension() directive shall request all other configured and present processors to power down. 
While the fatal source is Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing, while the fatal code is Symmetric Multiprocessing_SHUTDOWN_RESPONSE, the bsp_fatal_extension() directive shall power down the processor.
While the fatal source is not Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing or the fatal code is not Symmetric Multiprocessing_SHUTDOWN_RESPONSE, while all shutdown requests responded or a timeout occurred, the bsp_fatal_extension() directive shall halt the processor.
While the fatal source is not Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing or the fatal code is not Symmetric Multiprocessing_SHUTDOWN_RESPONSE, while all shutdown requests were issued, the bsp_fatal_extension() directive shall wait for at most approximately one millisecond for the power down response of all other configured and present processors.
The BSP shall define BSP_IDLE_TASK_BODY to bsp_idle_thread().
The bsp_idle_thread() function shall perform an endless loop which sets the processor in to the power-down mode using a write to %asr19 in each iteration.
The bsp_idle_thread() function shall be implemented according to Workaround 2 of {errata-gr712rc-08}.
The grlib_load_8 directive shall load an unsigned 8-bit value from the address specified by address and return it.
The grlib_load_16 directive shall load an unsigned 16-bit value from the address specified by address and return it.
The grlib_load_32 directive shall load an unsigned 32-bit value from the address specified by address and return it.
The grlib_load_64 directive shall load an unsigned 64-bit value from the address specified by address and return it.
The grlib_store_8 directive shall store the unsigned 8-bit value specified by value to the address specified by address.
The grlib_store_16 directive shall store the unsigned 16-bit value specified by value to the address specified by address.
The grlib_store_32 directive shall store the unsigned 32-bit value specified by value to the address specified by address.
The grlib_store_64 directive shall store the unsigned 64-bit value specified by value to the address specified by address.
The memcpy() function shall be specified by C11.
The memset() function shall be specified by C11.
The apbuart_outbyte_polled directive shall wait until the transmitter FIFO is empty and then write the characters specified by ch as an unsigned 8-bit value to the data register of the register block specified by regs.
The apbuart_outbyte_wait directive shall wait until the transmitter FIFO is empty indicated by the status register of the register block specified by regs.
The _Mutex_Acquire() directive shall seize the mutex as specified by /score/mtx/req/seize-wait.
The _Mutex_Acquire_timed() directive shall seize the mutex as specified by/score/mtx/req/seize-wait.
While the timeout parameter specifies a valid absolute CLOCK_REALTIME time point, while the mutex is not avaiable at the specified time point, the directive shall return with a statuscode of ETIMEDOUT.
While the mutex is not available, while the timeout parameter does not specify a valid absolute CLOCK_REALTIME time point, if an attempt to acquire the mutex is made, then the directive shall immediately return with a status code of EINVAL.
The mutex operations shall use the O(m) Independence-Preserving Protocol locking protocol.
The _Mutex_recursive_Acquire() directive shall seize the mutex as specified by/score/mtx/req/seize-wait.
The _Mutex_recursive_Acquire_timed() directive shall seize the mutex as specified by/score/mtx/req/seize-wait.
The mutex may be acquired recursively.
When an attempt to recursively acquire the mutex is made, the directive shall immediately return with a status code of EBUSY.
When an attempt to recursively acquire the mutex is made, the system shall terminate with the INTERNAL_ERROR_CORE fatal source and the INTER-NAL_ERROR_THREAD_QUEUE_DEADLOCK fatal code.
The _Mutex_Release() directive shall surrender the mutex as specified by/score/mtx/req/surrender.
The _Mutex_recursive_Try_acquire() directive shall seize the mutex as specified by/score/mtx/req/seize-try .
The _Mutex_Release() directive shall surrender the mutex as specified by/score/mtx/req/surrender.
The _Mutex_Try_acquire() directive shall seize the mutex as specified by/score/mtx/req/seize-try.
If the system detects a fatal error, then it shall terminate the system.
The rtems_barrier_ident directive shall identify an Classic Application Programming Interface barrier class object by its name as specified by /rtems/req/ident-local.
The Real-Time Executive for Multiprocessor Systems_SYMBOL_NAME macro shall expand to the ELF symbol name associated withthe C language identifier specified by the _name parameter.
The _name parameter value shall be expanded by the C preprocessor.
Where the target has a data cache, where the data cache can be disabled, when the rtems_cache_disable_data directive is called, the data cache shall be disabled.
Where the target has an instruction cache, where the instruction cache can be disabled, when the rtems_cache_disable_instruction directive is called, the instruction cache shall be disabled.
Where the target has a data cache, where the data cache can be enabled, when the rtems_cache_enable_data directive is called, the data cache shall be enabled.
Where the target has an instruction cache, where the instruction cache can be enabled, when the rtems_cache_enable_instruction directive is called, the instruction cache shall be enabled.
Where the target has a data cache, where the data cache can be ﬂushed, when the rtems_cache_ﬂush_entire_data directive is called, the data cache shall be ﬂushed.
Where the target has a data cache, where data cache lines can be ﬂushed, where the datacache is not coherent with all bus masters, when the rtems_cache_ﬂush_multiple_data_linesdirective is called, the data cache lines covering the memory area specified by begin and size shall be ﬂushed.
Where the target has a data cache, where the data cache can be frozen, when the rtems_cache_freeze_data directive is called, the data cache shall be frozen.
Where the target has an instruction cache, where the instruction cache can be frozen, when the rtems_cache_freeze_instruction directive is called, the instruction cache shall be frozen.
Where the target has a data cache, the rtems_cache_get_data_line_size directive shall return the size of the data cache line.
Where the target has a data cache, while the level parameter is greater than zero, while the level parameter is associated with a data cache level, the rtems_cache_get_data_cache_sizedirective shall return the size of the data cache of the level specified by level.
Where the target has a data cache, while the level parameter is equal to zero, the rtems_cache_get_data_cache_size directive shall return the size of the entire data cache.
Where the target has a data cache, while the level parameter is greater than zero, while the level parameter is not associated with a data cache level, the rtems_cache_get_data_cache_size directive shall return zero.
Where the target has an instruction cache, the rtems_cache_get_instruction_line_size directive shall return the size of the instruction cache line.
Where the target has an instruction cache, while the level parameter is greater than zero, while the level parameter is associated with an instruction cache level, the rtems_cache_get_instruction_cache_size directive shall return the size of the instruction cache of the level specified by level.
Where the target has an instruction cache, while the level parameter is equal to zero, the rtems_cache_get_instruction_cache_size directive shall return the size of the entire instruction cache.
Where the target has an instruction cache, while the level parameter is greater than zero, while the level parameter is not associated with an instruction cache level, the rtems_cache_get_instruction_cache_size directive shall return zero.
Where the target has a data cache or an instruction cache, the rtems_cache_get_maximal_line_size directive shall return the maximal cache line size of all caches.
Where the target has an instruction cache, where the instruction cache needs to be synchronized after code changes, when the rtems_cache_instruction_sync_after_code_change direc-tive is called, the instruction cache shall be synchronized so that the code in the memory area specified by begin and size will be fetched when it needs to be executed.
Where the target has a data cache, where the data cache can be ﬂushed and invalidated, when the rtems_cache_invalidate_entire_data directive is called, the data cache shall be ﬂushed and invalidated.
Where the target has an instruction cache, where the instruction cache can be invalidated, when the rtems_cache_invalidate_entire_instruction directive is called, the instruction cache shall be invalidated.
Where the target has a data cache, where data cache lines can be invalidated, where the data cache is not coherent with all bus masters, when the rtems_cache_invalidate_multiple_data_lines directive is called, the data cache lines covering the memory area specified by begin and size shall be invalidated.
Where the target has an instruction cache, where instruction cache lines can be invalidated, where the instruction cache is not coherent with all bus masters, when the rtems_cache_invalidate_multiple_instruction_lines directive is called, the instruction cache lines covering the memory area specified by begin and size shall be invalidated.
Where the target has a data cache, where the data cache can be frozen, when the rtems_cache_unfreeze_data directive is called, the data cache shall be not frozen.
Where the target has an instruction cache, where the instruction cache can be frozen, when the rtems_cache_unfreeze_instruction directive is called, the instruction cache shall be not frozen.
The directive shall return a time point during system initialization which is used by CLOCK_REALTIME.
The directive shall return the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC at some time point during the directive call.
The directive shall return the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC at some time point close to the directive call.
The directive shall return the time elapsed since the Unix epoch measured using the CLOCK_REALTIME at some time point during the directive call.
The directive shall return the time elapsed since the Unix epoch measured using the CLOCK_REALTIME at some time point close to the directive call.
The rtems_configuration_get_idle_task directive shall return the address of task body executed by each IDLE task.
The rtems_configuration_get_idle_task_stack_size directive shall return the task stack size of each IDLE task.
The rtems_configuration_get_interrupt_stack_size directive shall return the interrupt stacksize.
The rtems_configuration_get_maximum_barriers directive shall return the maximum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicBarrier that can be concurrently active.
The rtems_configuration_get_maximum_extensions directive shall return the maximum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicUserExt that can be concurrently active.
The rtems_configuration_get_maximum_message_queues directive shall return the maximum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicMessage that can be concurrently active.
The rtems_configuration_get_maximum_partitions directive shall return the maximum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicPart that can be concurrently active.
The rtems_configuration_get_maximum_periods directive shall return the maximum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicRatemon that can be concurrently active.
The rtems_configuration_get_maximum_ports directive shall return the maximum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicDPMem that can be concurrently active.
The rtems_configuration_get_maximum_processors directive shall return the maximum number of processors which can be managed by the system.
The rtems_configuration_get_maximum_regions directive shall return the maximum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicRegion that can be concurrently active.
The rtems_configuration_get_maximum_semaphores directive shall return the maximumnumber of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicSem that can be concurrently active.
The rtems_configuration_get_maximum_tasks directive shall return the maximum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicTasks that can be concurrently active.
The rtems_configuration_get_maximum_timers directive shall return the maximum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicTimer that can be concurrently active.
The rtems_configuration_get_microseconds_per_tick directive shall return the clock tick interval in microseconds.
The rtems_configuration_get_milliseconds_per_tick directive shall return the clock tick interval in milliseconds.
The rtems_configuration_get_nanoseconds_per_tick directive shall return the clock tick interval in nanoseconds.
The rtems_configuration_get_stack_allocate_for_idle_hook directive shall return the stack allocator allocate handler used to allocate the task stack of each IDLE task.
The rtems_configuration_get_stack_allocate_hook directive shall return the address of the task stack allocator which is used to allocate the stack for a task which is not an IDLE task.
The rtems_configuration_get_stack_allocator_avoids_work_space directive shall return the option value configured by CONFIG-URE_TASK_STACK_ALLOCATOR_AVOIDS_WORK_SPACE.
The rtems_configuration_get_stack_free_hook directive shall return the address of the taskstack deallocator which is used to free the stack of a task which was allocated by the taskstack allocator.
The rtems_configuration_get_ticks_per_timeslice directive shall return the number of clockticks per timeslice.
When rtems_cpu_usage_reset is called, the CPU usage shall be set to zero for each thread.
The Real-Time Executive for Multiprocessor Systems_PENDING_EVENTS constant shall be a constant expression which evaluates to avalue of zero.
The rtems_event_receive directive shall receive events from the application event set of a task as specified by /rtems/event/req/send-receive.
The rtems_event_send directive shall send events to the application event set of a task asspecified by /rtems/event/req/send-receive.
When the event send and receive directive variants are called in the specified system condition.
The rtems_event_system_receive directive shall receive events from the system event set of a task as specified by /rtems/event/req/send-receive.
The rtems_event_system_send directive shall send events to the system event set of a task as specified by /rtems/event/req/send-receive.
When rtems_fatal is called, the system shall terminate with a fatal source specified by the fatal_source parameter and a fatal code specified by the fatal_code parameter.
When the directive is called, maskable interrupts shall be disabled on a processor which executed at least one instruction of the directive.
When the rtems_interrupt_entry_initialize directive is called, the arg member of the object referenced by the entry parameter shall be set to the value of the arg.
When the rtems_interrupt_entry_initialize directive is called, the handler member of the object referenced by the entry parameter shall be set to the value of the routine.
When the rtems_interrupt_entry_initialize directive is called, the info member of the object referenced by the entry parameter shall be set to the value of the arg.
When the rtems_interrupt_entry_initialize directive is called, the next member of the object referenced by the entry parameter shall be set to the value equal to NULL.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_ENTRY_INITIALIZER is used to statically initialize an object of type rtems_interrupt_entry, the arg member of the object shall be initialized to the value of the _arg .
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_ENTRY_INITIALIZER is used to statically initialize an object of type rtems_interrupt_entry, the handler member of the object shall be initialized to the value of the _routine .
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_ENTRY_INITIALIZER is used to statically initialize an object of type rtems_interrupt_entry, the info member of the object shall be initialized to the value of the _info .
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_ENTRY_INITIALIZER is used to statically initialize an object of type rtems_interrupt_entry, the next member of the object shall be initialized to a value equal to NULL.
When the rtems_interrupt_local_disable directive is called, the status of the maskable interrupts before maskable interrupts are disabled by the directive shall be assigned to the variable specified by the _isr_cookie parameter.
When the rtems_interrupt_local_enable directive is called, the status of maskable interrupts shall be restored according to the _isr_cookie parameter.
When the directive is called, the lock contained in the object referenced by the _lock parameter shall be acquired.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_DECLARE is used, it shall expand to an object declaration with an identifier specified by the _designator parameter.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_DECLARE is used, it shall expand to an object declaration with a specifier specified by the _specifier parameter.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_DEFINE is used, it shall expand to an object definition with an identifier specified by the _designator parameter.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_DEFINE is used, it shall expand to an object definition with a specifier specified by the _specifier parameter.
When the rtems_interrupt_lock_destroy directive is called, the lock contained in the object referenced by the _lock parameter shall be destroyed.
When the rtems_interrupt_lock_initialize directive is called, the lock contained in the object referenced by the _lock parameter shall be initialized so that it is available.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_INITIALIZER is used to statically initialize an object of type rtems_interrupt_lock, the lock contained in the object shall be initialized so that it is available.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_MEMBER is used, it shall expand to structure or union member declaration with an identifier specified by the _specifier parameter.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_MEMBER is used, it shall expand to structure or union member declaration with a type of rtems_interrupt_lock.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_REFERENCE is used, it shall expand to an object reference definition with an identifier specified by the _designator parameter.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_REFERENCE is used, it shall expand to an object reference definition which is initialized to the object reference specified by the _target parameter.
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_REFERENCE is used, it shall expand to an object ref-rence definition with a type of a pointer to rtems_interrupt_lock.
When the directive is called, the lock contained in the object referenced by the _lock parameter shall be released.
When the rtems_interrupt_lock_release directive is called, the status of maskable interrupts shall be restored according to the _lock_context parameter.
When the directive is called, the status of the maskable interrupts before maskable interrupts are disabled by the directive shall be stored to the lock context parameter.
When the function referenced by BSP_output_char is called, it shall output the character specified by the parameter to the kernel character output device.
While the BSP_poll_char pointer references a function, while the kernel character input device used by the function has a character enqueued, the function shall dequeue the least recently enqueued character and return it as an unsigned character value.
While the BSP_poll_char pointer references a function, while the kernel character input device used by the function has no character enqueued, the function shall return minus one.
The rtems_message_queue_ident directive shall identify an Classic Application Programming Interface message queue classobject by its name as specified by /rtems/req/ident.
When the /rtems/mode/if/interrupt-level macro is used, it shall expand to a constant expression which computes the bitwise and of the value specified by the _interrupt_levelparameter and Real-Time Executive for Multiprocessor Systems_INTERRUPT_MASK.
When the rtems_build_name directive is called, the directive shall return the return value ofa call to rtems_build_name.
The result of rtems_object_get_local_node shall be equal to the local node number.
The Real-Time Executive for Multiprocessor Systems_PARTITION_ALIGNMENT constant shall expand to a constant expression which evaluates to the value of CPU_SIZEOF_POINTER.
The count of buffers available for use from a partition shall be exactly the buffer area length divided by the buffer size (integer division) specified at partition creation.
A partition shall maintain free buffers in FIFO order.
The rtems_partition_ident directive shall identify an Classic Application Programming Interface partition class object by its name as specified by /rtems/req/ident.
The rtems_rate_monotonic_ident directive shall identify an Classic Application Programming Interface rate monotonic classobject by its name as specified by /rtems/req/ident-local.
When the rtems_scheduler_get_processor directive is called, the directive shall return the return value of a call to rtems_scheduler_get_processor.
When the rtems_scheduler_get_processor_maximum directive is called, the directive shall return the return value of a call to rtems_scheduler_get_processor_maximum.
The return value of the rtems_scheduler_get_processor_maximum directive shall be the minimum of the processors available at the target and the CONFIG-URE_MAXIMUM_PROCESSORS application configuration option value.
When the rtems_scheduler_get_processor_set() ( processor-set ) directive is called.
The return value of the rtems_scheduler_get_processor directive shall be the index of a processor which executed at least one instruction of the directive call.
The rtems_semaphore_ident directive shall identify an Classic Application Programming Interface semaphore class object by its name as specified by /rtems/req/ident.
While a thread is waiting to obtain a Multiprocessor Resource-Sharing Protocol semaphore, while its current priority changed so that it is higher than the ceiling priority of the semaphore, the thread is allowed to become the new owner of the semaphore.
Where an uniprocessor scheduler is configured, the owner of a semaphore created with the Real-Time Executive for Multiprocessor Systems_MULTIPROCESSOR_RESOURCE_SHARING attribute shall not be made sticky.
The Real-Time Executive for Multiprocessor Systems_STATUS_CODES_FIRST constant shall be equal to the minimum value of all rtems_status_code enumerators.
The Real-Time Executive for Multiprocessor Systems_STATUS_CODES_LAST constant shall be equal to the maximum value of all rtems_status_code enumerators.
When the call to rtems_name_to_characters returned, the object referenced by the c1 parameter shall be set the value of name divided by 16777216 modulo 256.
When the call to rtems_name_to_characters returned, the object referenced by the c2 parameter shall be set the value of name divided by 65536 modulo 256.
When the call to rtems_name_to_characters returned, the object referenced by the c3 parameter shall be set the value of name divided by 256 modulo 256.
When the call to rtems_name_to_characters returned, the object referenced by the c4 parameter shall be set the value of name modulo 256.
The Real-Time Executive for Multiprocessor Systems_CONFIGURED_MINIMUM_STACK_SIZE constant shall expand to a constant expression which evaluates to the value of zero.
When a task is constructed, the home scheduler of the constructed task shall be set to the home scheduler of the task calling the rtems_task_construct directive at some time pointduring the directive call.
When a task is created, the home scheduler of the created task shall be set to the homescheduler of the task calling the rtems_task_create directive at some time point during the directive call.
While an iteration over all tasks was started by calling rtems_task_iterate, while no task exists which was not visited, the iteration shall stop and then the object allocator lock shall be released.
When rtems_task_iterate is called, the calling task shall obtain the object allocator lock and then start an iteration over all tasks.
While an iteration over all tasks was started by calling rtems_task_iterate, when the function specified by the visitor returns true during the iteration, the iteration shall stop and the object allocator lock shall be released.
The Real-Time Executive for Multiprocessor Systems_MAXIMUM_PRIORITY runtime constant shall be equal to the lowest priority of the scheduler with index zero.
The Real-Time Executive for Multiprocessor Systems_MINIMUM_PRIORITY constant shall expand to a constant expression which evaluates to the highest task priority available to application tasks.
The Real-Time Executive for Multiprocessor Systems_MINIMUM_STACK_SIZE constant shall expand to a constant expression which evaluates to the value of STACK_MINIMUM_SIZE.
The /rtems/task/if/no-priority constant shall expand to a constant expression which evaluates to the value of Real-Time Executive for Multiprocessor Systems_CURRENT_PRIORITY.
The rtems_task_self directive call shall return the object identifier of the calling task.
While the Real-Time Executive for Multiprocessor Systems_SELF constant is used as a task identifier parameter in a directive call, it shall be associated with the calling task.
The Real-Time Executive for Multiprocessor Systems_TASK_STORAGE_ALIGNMENT constant shall expand to a constant expression which evaluates to the value of CPU_STACK_ALIGNMENT.
The timer scheduled at the same processor with the same expiration time point shall fire in FIFO order.
The rtems_timer_ident directive shall identify an Classic Application Programming Interface timer class object by its name asspecified by /rtems/req/ident-local.
While the user extensions are iterated to invoke the fatal extensions, when an extension set is removed, the removed extension set shall not be a next extension set for any iteration in progress after the removal.
The Real-Time Executive for Multiprocessor Systems_ID_NONE constant shall be a constant expression which evaluates to an invalid object identifier.
The fatal user extensions shall be invoked in extension forward order.
The rtems_extension_ident directive shall identify an Classic Application Programming Interface user extension class object by its name as specified by /rtems/req/ident-local.
While the user extensions are iterated to invoke the thread begin extensions, when an extension set is removed, the removed extension set shall not be a next extension set for any iteration in progress after the removal.
The thread begin user extensions shall be invoked in extension forward order.
The thread invoking the thread create user extensions shall be the owner of the allocator mutex.
While the user extensions are iterated to invoke the thread create extensions, when an extension set is removed, the removed extension set shall not be a next extension set for any iteration in progress after the removal.
The thread create user extensions shall be invoked in extension forward order.
The thread invoking the thread delete user extensions shall be the owner of the allocator mutex.
While the user extensions are iterated to invoke the thread delete extensions, when an extension set is removed, the removed extension set shall not be a next extension set for any iteration in progress after the removal.
The thread delete user extensions shall be invoked in extension reverse order.
While the user extensions are iterated to invoke the thread exitted extensions, when an extension set is removed, the removed extension set shall not be a next extension set for any iteration in progress after the removal.
The thread exitted user extensions shall be invoked in extension forward order.
While the user extensions are iterated to invoke the thread restart extensions, when an extension set is removed, the removed extension set shall not be a next extension set for any iteration in progress after the removal.
The thread restart user extensions shall be invoked in extension forward order.
While the user extensions are iterated to invoke the thread start extensions, when an extension set is removed, the removed extension set shall not be a next extension set for any iteration in progress after the removal.
The thread start user extensions shall be invoked in extension forward order.
The thread switch user extensions shall be invoked in extension forward order.
While the user extensions are iterated to invoke the thread terminate extensions, when an extension set is removed, the removed extension set shall not be a next extension set for any iteration in progress after the removal.
The thread terminate user extensions shall be invoked in extension reverse order.
The _CPU_Fatal_halt() function shall halt or reset the target.
The _CPU_Fatal_halt() directive shall cause a system error halt with the primary exit code set to the fatal source and the secondary exit code set to the fatal code.
The _Terminate() function shall terminate the system.
While _Terminate() executes, when the system state was set, a shutdown request to all configured processors shall be issued.
While _Terminate() executes, when the shutdown request was issued, the system shall halt.
While _Terminate() executes, when the fatal extensions were invoked, the system state shall be set to terminated.
When _Terminate() is called, the fatal user extensions shall be invoked with the fatal source and fatal code specified by the respective parameter.
The object services shall use a mutex to protect the object allocation and deallocation.
If obtaining the object allocator mutex would result in a deadlock, then the system shall terminate with the INTERNAL_ERROR_CORE fatal source and the INTERNAL_ERROR_THREAD_QUEUE_DEADLOCK fatal code.
While a thread is registered for help in a helping scheduler, while the thread is scheduled by another scheduler or blocked, when the helping scheduler tries to schedule the thread, the thread shall be blocked with respect to the helping scheduler. 
While a thread is registered for help in its home scheduler, while the thread is scheduled by another scheduler, while the thread is not sticky , when the home scheduler tries to schedule the thread, the thread shall be blocked with respect to the home scheduler.
When a need for help is detected for a thread, the ask for help request shall be registered on the current processor.
While a thread is scheduled by the home scheduler, while an idle thread executes on behalf of the thread in the home scheduler, when the thread is blocked, the idle thread executing on behalf of the thread shall continue to execute on behalf of the thread.
While an idle thread is scheduled on behalf of a thread by the home scheduler, while the thread is not scheduled by another scheduler, when the thread is rescheduled by the homescheduler, the thread shall be scheduled.
While a thread is scheduled by a helping scheduler, while the thread is blocked, when the thread is preempted by the helping scheduler, the thread shall be blocked by the helpingscheduler.
While the system is initialized, if the boot processor is not assigned to a scheduler, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and the Symmetric Multiprocessing_FATAL_BOOT_PROCESSOR_NOT_ASSIGNED_TO_SCHEDULER fatal code.
While the system is initialized, if a mandatory processor defined by the application configuration is not present, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessingfatal source and the Symmetric Multiprocessing_FATAL_MANDATORY_PROCESSOR_NOT_PRESENT fatal code.
While the system is initialized, if multitasking is started on a processor those index is greater than or equal to the processor maximum defined by the application configuration, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and the Symmetric Multiprocessing_FATAL_MULTITASKING_START_ON_INVALID_PROCESSOR fatal code.
While the system is initialized, if multitasking is started on a processor which has no scheduler assigned by the application configuration, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and the Symmetric Multiprocessing_FATAL_MULTITASKING_START_ON_UNASSIGNED_PROCESSOR fatal code.
Where the configured scheduler does support exactly one processor, where the system has not exactly one processor, if the system is initialized, then the sysem shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and the Symmetric Multiprocessing_FATAL_SCHEDULER_REQUIRES_EXACTLY_ONE_PROCESSOR fatal code.
If the processor receives an Symmetric Multiprocessing shutdown request message, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and the Symmetric Multiprocessing_SHUTDOWN_RESPONSE fatal code.
While the system is initialized, if the start of a mandatory processor defined by the application configuration fails, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessingfatal source and the Symmetric Multiprocessing_FATAL_START_OF_MANDATORY_PROCESSOR_FAILED fatal code.
If multitasking is started on a not online processor, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and the Symmetric Multiprocessing_FATAL_START_ON_NOT_ONLINE_PROCESSOR fatal code.
If the target processor of a job is not in the initial, ready to start multiprocessing, or up state, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and the Symmetric Multiprocessing_FATAL_START_OF_MANDATORY_PROCESSOR_FAILED fatal code.
Per-processor jobs shall be processed in FIFO order.
Processors which were successfully started shall be marked as online.
While the system is initialized, if the start of an optional processor defined by the application configuration fails, then the system initialization shall continue.
Processors which failed to start shall not be marked as online.
While a terminating thread has exactly one joining thread, while the joining thread can be cancelled, if the terminating thread cancels the joining thread, then the terminating thread shall wait for threads to join. 
While the thread dispatch disable level is not equal to one, if a direct thread dispatch is done, then the system shall terminate with the INTERNAL_ERROR_CORE fatal source and the INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL fatal code.
Where the system needs interprocessor interrupts, if a thread dispatch is done with maskable interrupts disabled, then the system shall terminate with the INTERNAL_ERROR_CORE fatal source and the INTERNAL_ERROR_BAD_THREAD_DISPATCH_ENVIRONMENT fatal code.
If a thread body function returned and the thread exitted extension invocation for the thread returned, then the system shall terminate with the INTERNAL_ERROR_CORE fatal sourceand the INTERNAL_ERROR_THREAD_EXITTED fatal code.
While a thread is pinned, while the thread executes on a processor which is not owned by its home scheduler, the thread shall only use the scheduler of the processor to which it is pinned.
While a thread is suspended, the thread may be unpinned.
While a thread is suspended, the thread shall not reconsider help requests.
Where the system does not need inter-processor interrupts, when a thread dispatch is done with maskable interrupts disabled, the thread dispatch shall be carried out.
The alignment of thread-local storage objects may be greater than CPU_STACK_ALIGNMENT.
While the thread entry execution begins, the value of non-zero initialized thread-local storage objects shall be the initialization value.
Where the configured maximum thread-local storage size is equal to zero, the thread-local storage allocation size shall be defined by the thread-local storage size of the application executable.
While the thread entry execution begins, the storage space of zero initialized thread-localstorage objects shall be cleared to zero.
The initial value of the CLOCK_MONOTONIC shall be 0000-00-00T00:00:01.000000000.
While no timecounter is installed, the CLOCK_MONOTONIC shall remain at the initial value.
The initial value of the CLOCK_REALTIME shall be 1988-01-01T00:00:00.000000000.
While no timecounter is installed, the CLOCK_REALTIME shall remain at the initial value.
The directives to get time values in a coarse resolution shall not use the currently installed timecounter.
The directives to get time values in the highest resolution shall use the currently installed timecounter to get a clock snapshot.
While the timehand used to get the time was not updated for one second or more, while the timecounter of the timehand did not overﬂow, the directives to get time values in the highest resolution shall return the correct time.
While the timecounter to install has a quality level equal to the quality level of the currently installed timecounter, while the timecounter to install has a higher frequancy greater than the frequency of the currently installed timecounter, the timecounter to install shall be installed.
While the timecounter to install has a quality level greater than the quality level of the currently installed timecounter, the timecounter to install shall be installed.
While the timehand is updated, when the NTP handler is called, the value returned by the adjustment parameter shall be used to adjust the timecounter frequency of the timehand.
While the timehand is updated, when the NTP handler is called, the value returned by the new sec parameter shall define the seconds value of the CLOCK_REALTIME time point of the timehand.
Let T be the seconds value of the CLOCK_REALTIME time point of the timehand which is currently updated, let S be the seconds value of the CLOCK_REALTIME time point of the previous timehand, let D be T minus S, while the NTP handler is not NULL, while D is greater than or equal to one, while D is less than or equal to 200, while the timehand is updated, the NTP handler shall be called exactly D times.
Let T be the seconds value of the CLOCK_REALTIME time point of the timehand which is currently updated, let S be the seconds value of the CLOCK_REALTIME time point of the previous timehand, let D be T minus S, while the NTP handler is not NULL, while D is greater than 200, while the timehand is updated, the NTP handler shall be called exactly two times.
While the oldest timehand was not updated for one second or more, while the time interval from the time point of the timehand to the time point of the update is measureable with the timecounter of the timehand, the time point of the timehand shall be incremented by the timeinterval.
When the simple timecounter tick service is called, the time points of the current timehand shall be advanced by the time interval specified by the delta parameter.
When the simple timecounter tick service is called, the timecounter offset of the current timehand shall be set to the offset specified by the offset parameter.
While a thread A tries to enqueue on a thread queue X, while a thread B tries to enqueue on a thread queue Y, while the thread queue dependency graph built up by threads A and B contains a cycle, the deadlock shall be detected.
While no deadlock was detected in a sticky thread queue enqueue, while the thread dispatch disable level is not equal to one, if the sticky thread queue enqueue is performed, then the system shall terminate with the INTERNAL_ERROR_CORE fatal source and the INTER-NAL_ERROR_THREAD_QUEUE_ENQUEUE_STICKY_FROM_BAD_STATE fatal code.
The thread queue ﬂush operation shall invoke the caller provided filter handler for each thread to extract.
When the caller provided filter handler returns a value equal to NULL, the thread queue ﬂushoperation shall stop extracting threads from the thread queue.
While the extracted thread is in the blocked wait state, the thread queue ﬂush operation shall remove the thread timer.
While the extracted thread is in the blocked wait state, the thread queue ﬂush operation shall unblock the thread.
Where the thread queue uses a priority discipline, when the priority of an enqueued thread changes, the position of the enqueued thread shall be changed to reﬂect its new priority.
While the execution environment is below environments, while the barrier is an automatic release barrier, while the measurement sample is the runtime of exactly one successful call to rtems_barrier_wait which automatically releases the barrier, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with distinct home schedulers. Let B be a time point measured by U right before a call to rtems_barrier_wait which automatically releases the barrier. Let E be a time point measured by V right after a call to rtems_barrier_wait returns successfully due to the rtems_barrier_wait call associated with B. While the execution environment is below environments, while the barrier is an automatic release barrier, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while the barrier is a manual release barrier, while the measurement sample is the runtime of exactly one successful call to rtems_barrier_release which does not preempt the caller, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_barrier_release which preempts the caller. Let E be a timepoint measured by V right after a call to rtems_barrier_wait returns successfully due to the rtems_barrier_release call associated with B. While the execution environment is below environments, while the barrier is a manual release barrier, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicBarrier directives shall be measured.
Let U be an interrupt service and V be a task which both execute on the same processor. Let B be a time point measured by U right before a call to rtems_event_send which unblocks task V which preempts the executing task. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while task V waits for events, while the measurement sample is E−B, when exactly 100 samples are collected, the below limitkinds shall be below limit conditions.
While the execution environment is below environments, while a task waits for events, while the measurement sample is the runtime of exactly one successful call to rtems_event_send which does satisfy the event condition of the waiting task which does not preempt the caller, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with distinct home schedulers. Let B be a time point measured by U right before a call to rtems_event_send which does satisfy the event condition of the waiting task V which is scheduled on another processor. Let E be a time point measured by V right afterthe first context switch after B. While the execution environment is below environments, while the task V waits for events, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_event_send which does satisfy the event condition of the waiting task V which does preempt the caller. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while the task V waits for events, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicEvent directives shall be measured.
While the execution environment is below environments, while a message queue is empty , while the measurement sample is the runtime of exactly one unsatisfied call tortems_message_queue_send, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_message_queue_receive which blocks on the message queue with no timeout. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while a message queue is empty , while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_message_queue_receive which blocks on the message queue with a timeout. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while a message queue is empty , while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicMessage directives shall be measured.
While the execution environment is below environments, while a message queue is empty , while no task waits on the message queue, while the measurement sample is the runtime of exactly one successful call to rtems_message_queue_send, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while a message queue is empty , while exactly one task waits on the message queue, while the measurement sample is the runtime of exactly one successful call to rtems_message_queue_send which does not preempt the caller,when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with distinct home schedulers. Let B be a time point measured by U right before a call to rtems_message_queue_send which unblocks the waiting task V which is scheduled on another processor. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while a message queue is empty, while only task V waits on the message queue, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_message_queue_send which unblocks the waiting task V which does preempt the caller. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while a message queue is empty , while only task V waits on the message queue, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while a partition has exactly 100 free buffers, while the measurement sample is the runtime of exactly one successful call to rtems_partition_get_buffer, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while a partition has no free buffers, while the measurement sample is the runtime of exactly one unsatisified call to rtems_partition_get_buffer, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while a partition has exactly 100 minus one free buffers, while the measurement sample is the runtime of exactly one successful call to rtems_partition_return_buffer, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicPart directives shall be measured.
The runtime of the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassic directives shall be measured.
While the execution environment is below environments, while the semaphore is a priority inheritance mutex, while the measurement sample is the runtime of exactly one successful call to rtems_semaphore_obtain which immediately obtains the mutex, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while the semaphore is a priority inheritance mutex, while the measurement sample is the runtime of exactly one successful call to rtems_semaphore_release which does not unblock a waiting task, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while the semaphore is a priority inheritance mutex, while the measurement sample is the runtime of exactly one successful call to rtems_semaphore_release which does unblock exactly one waiting task which does not preempt the caller, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with distinct home schedulers. Let B be a time point measured by U right before a call to rtems_semaphore_release which unblocks task V which is scheduled on another processor. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while the semaphore is a priority inheritance mutex, while exactly task V waits on the mutex, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_semaphore_release which unblocks task V which does preempt the caller. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while the semaphore is a priority inheritance mutex, while exactly task V waits for the mutex, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while the semaphore is a priority inheritance mutex, while the measurement sample is the runtime of exactly one unsatisfied call to rtems_semaphore_obtain which immediately returns, when exactly 100 samples are collected,the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_semaphore_obtain which blocks on the mutex with no timeout. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while the semaphore is a priority inheritance mutex, while the measurement sample is E−B, when exactly 100 samples arecollected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_semaphore_obtain which blocks on the mutex with a timeout. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while the semaphore is a priority inheritance mutex, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while the measurement sample is the runtime of exactly one successful call to rtems_task_construct, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while the measurement sample is the runtime of exactly one successful call to rtems_task_restart which does not preempt the caller, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_task_restart which starts task V which preempts the caller. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while the measurement sample is E−B, the below limit kinds shall be below limit conditions.
Let B be a time point measured by a task right before a call to rtems_task_restart which restarts the caller. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while the measurement sample is E−B, the below limit kinds shall be below limit conditions.
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicTasks directives shall be measured.
While the execution environment is below environments, while the measurement sample is the runtime of exactly one successful call to rtems_task_set_scheduler which changes the scheduler of the caller, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while the measurement sample is the runtime of exactly one successful call to rtems_task_set_scheduler which does not change the scheduler or priority , when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while the measurement sample is the runtime of exactly one successful call to rtems_task_set_scheduler which moves the task to the home scheduler of the caller which does not preempt the caller, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the distinct home schedulers. Let B be a time point measured by U right before a call to rtems_task_set_scheduler which moves task V to the home scheduler of U which preempts the caller. Let E be a time point measured by V right after the first context switch after B. While the execution environment is below environments, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
While the execution environment is below environments, while the measurement sample is the runtime of exactly one successful call to rtems_task_start which does not preempt the caller, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
Let U and V be two tasks with the same home scheduler. Let B be a time point measured by U right before a call to rtems_task_start which starts task V which preempts the caller. Let E be atime point measured by V right after the first context switch after B. While the execution environment is below environments, while the measurement sample is E−B, when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.
The Application Programming Interface shall contain the application configuration interface.
The BSPs shall be a software architecture component containing the implementation specificto targets and devices.
The shared BSP interrupt support shall be a component containing functions used to implement a Clock Driver.
The fatal BSP support shall be a component containing functions used to indicate target-specific fatal errors.
The shared BSP interrupt support shall be a component containing functions used to manageand process interrupts.
The shared BSP support shall be a component containing functions used by multiple targets.
The shared BSP startup support shall be a component containing functions used to initialize the system.
The BSP component shall have a component containing the SPARC BSPs.
The SPARC BSP component shall have a component containing the LEON3 compatible BSPs.
The software product shall use the define SPARC_LEON3FT_B2BST_NOP in assembler language source code to insert no p instructions required by the errata workaround.
The software product shall take the errata 1 (FTAHBRAM: On-chip Memory not cacheable) into account.
The software product shall take the errata 2 (CAN OC: interrupt can be cleared before read) into account.
The software product shall take the errata 3 (GRSPW2: interrupt can be lost) into account.
The software product shall take the errata 4 (GRSPW2: CRC calculation partially incorrect) into account.
The software product shall take the errata 5 (SPICTRL: transfers in progress bit not cleared) into account.
The software product shall take the errata 6 (SPICTRL: back-to-back transfers) into account.
The software product shall take the errata 7 (FTMCTLR: EDAC usage with 8-bit wide memory) into account.
The software product shall take the errata 8 (LEON3FT Cache Controller: Incorrect Bus Access After Power-Down) into account.
The software product shall take the errata 9 (Failing SDRAM Access After Uncorrectable EDACError) into account.
The software product shall take the errata 10 (MIL-STD-1553B core duplicate interrupt assertion) into account.
The software product shall take the errata 11 (Technical Note on LEON SRMMU Behaviour) into account.
The software product shall take the errata 12 (Technical Note on GRETH Ethernet Controller Behaviour) into account.
The software product shall take the errata 13 (Technical Note on Stale Cache Entry AfterStore with Data Tag Parity Error) into account.
The software product shall take the errata 14 (Never disable the TLB when the MMU isenabled) into account.
The software product shall take the errata 15 (Technical Note on LEON3/FT AHB Lock Release During Atomic Operation) into account.
The software product shall take the errata 16 (Technical Note on GR712RC Incorrect Annulation of Floating-point Operation on) into account.
The software product shall take the errata 17 (Technical Note on GRFPU Floating-point controller: Missing FDIV/FSQRT Result) into account.
The software product shall take the errata 18 (Don’t break into debug mode on RETT instructions) into account.
The software product shall take the errata 19 (Stores to ASI 0x1C may update data cache) into account.
The software product shall take the errata 20 (Technical Note on LEON3FT RETT RestartErrata) into account.
The software product shall be compiled using the -mfix-gr712rc compiler option.
The software product shall provide assembler language macros to help implementing workarounds for the errata.
The super core shall have a component containing the futex implementation those interfaces are defined by Newlib.
The super core shall have a component containing the system lock mutex implementation those interfaces are defined by Newlib.
The software product shall have software architecture components containing the device drivers.
The interfaces used or provided by the system shall be a contained in interface domains.
The software product shall take target errata into account.
The software product shall have software architecture components containing the implementation.
The software product shall be a real-time operating system.
The system shall have a procedure to terminate the system.
The validation and unit tests shall be a contained in test suites.
The system shall document usage constraints of interfaces.
The software architecture shall have a component containing the attribute support implementation.
The software architecture shall have a component containing the Barrier Manager implementation.
The software architecture shall have a component containing the Clock Manager implementation.
The software architecture shall have a component containing the Event Manager implementation.
The software architecture shall have a component containing the Message Manager implementation.
The software architecture shall have a component containing the Partition Manager implementation.
The software architecture shall have a component containing the Rate Monotonic Manager implementation.
The software architecture shall have a component containing the Classic Application Programming Interface implementation.
The software architecture shall have a component containing the Scheduler Manager implementation.
The software architecture shall have a component containing the Semaphore Manager implementation.
The software architecture shall have a component containing the Signal Manager implementation.
The software architecture shall have a component containing the Task Manager implementation.
The software architecture shall have a component containing the Timer Manager implementation.
The software architecture shall have a component containing the User Extensions Manager implementation.
The super core shall have a component containing the implementation specific to the target architecture and target.
The super core shall be a software architecture component containing the implementation used by multiple Application Programming Interfaces.
The super core shall have a component containing the system termination handling.
The super core shall have a component containing the mutual exclusion object implementation.
The super core shall have a component containing the object services implementation.
The super core shall have a component containing the scheduler implementations.
The super core shall have a component containing the Earliest Deadline First Symmetric Multiprocessing /glossary/scheduler implementation.
The super core shall have a component containing the Symmetric Multiprocessing /glossary/scheduler implementations.
The super core shall have a component containing the semaphore object implementation.
The super core shall have a component containing the Symmetric Multiprocessing-specific implementation.
The super core shall have a component containing the thread implementation.
Pinning of threads to a processor shall be supported.
The timecounter component shall provide the CLOCK_MONOTONIC.
The timecounter component shall provide the CLOCK_REALTIME.
The timecounter component shall implement directives to get time values in the highest resolution available to the system.
The timecounter component shall implement directives to get time values in a coarse resolution.
The directives to get time values shall use a sequence lock to synchronize the reader with exactly one writer.
The super core shall have a component containing the clock implementation.
The timecounter component shall implement a directive to install a timecounter.
The clock implementation shall optionally use a handler to do time adjustments and second updates through a NTP service.
The clock implementation shall provide a simple timecounter tick service for timecounterdevices with a period equal to the clock tick interval.
The super core shall have a component containing the thread queue implementation.
The thread queue operations shall support deadlock detection.
The state of each thread queue object shall be protected by an object-specific lock.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with the clock driver enabled (CONFIG-URE_APPLICATION_NEEDS_CLOCK_DRIVER).
The system shall provide benchmark programs to show the static memory usage of features.
The system shall provide a benchmark program to show the static memory usage of a basicapplication configuration with CONFIGURE_MAXIMUM_BARRIERS defined to one and calls to rtems_barrier_create, rtems_barrier_wait, and rtems_barrier_release.
The system shall provide a benchmark program to show the static memory usage of a basic ap-plication configuration with CONFIGURE_MAXIMUM_BARRIERS defined to one and calls to rtems_barrier_create, rtems_barrier_wait, rtems_barrier_release, and rtems_barrier_delete.
The system shall provide a benchmark program to show the static memory usage of a basicapplication configuration with a call to rtems_clock_get_uptime.
The system shall provide a benchmark program to show the static memory usage of a basicapplication configuration with a call to rtems_clock_set.
The system shall provide a benchmark program to show the static memory usage of a basicapplication configuration with calls to rtems_clock_set and rtems_clock_get_tod.
The system shall provide a benchmark program to show the static memory usage of a basicapplication configuration with calls to rtems_event_send and rtems_event_receive.
The system shall provide a benchmark program to show the static memory usage of a basicapplication configuration with a call to rtems_fatal.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_message_queue_construct, rtems_message_queue_broadcast, and rtems_message_queue_receive.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_message_queue_construct, rtems_message_queue_send, and rtems_message_queue_receive.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_message_queue_construct, rtems_message_queue_send, rtems_message_queue_receive, andrtems_message_queue_delete.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_message_queue_construct, rtems_message_queue_urgent, and rtems_message_queue_receive.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_PARTITIONS defined to one and calls to rtems_partition_create, rtems_partition_get_buffer, and rtems_partition_return_buffer.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_PARTITIONS defined to one and calls to rtems_partition_create, rtems_partition_get_buffer, rtems_partition_return_buffer,and rtems_partition_delete.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_PERIODS defined to one and calls to rtems_rate_monotonic_create and rtems_rate_monotonic_period.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_PERIODS definedto one and calls to rtems_rate_monotonic_create, rtems_rate_monotonic_period, andrtems_rate_monotonic_delete.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_PROCESSORS defined to one using the Symmetric Multiprocessing Earliest Deadline First scheduler (CONFIGURE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_PROCESSORS defined to two using the global Symmetric Multiprocessing Earliest Deadline First scheduler (CONFIGURE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_PROCESSORS defined to four using the global Symmetric Multiprocessing Earliest Deadline First scheduler (CONFIGURE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_PROCESSORS defined to two using one Symmetric Multiprocessing Earliest Deadline First scheduler for each configured processor (CONFIG-URE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_PROCESSORS defined to four using one Symmetric Multiprocessing Earliest Deadline First scheduler for each configured processor (CONFIG-URE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_scheduler_add_processor.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_scheduler_remove_processor.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_SEMAPHORES defined to one and calls to rtems_semaphore_create, rtems_semaphore_obtain, and rtems_semaphore_release.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_SEMAPHORES defined to one and calls to rtems_semaphore_create, rtems_semaphore_obtain, rtems_semaphore_release, andrtems_semaphore_delete.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_signal_catch and rtems_signal_send.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_delete.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_exit.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_get_affinity.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_get_priority.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_get_scheduler.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_mode.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_restart.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_set_affinity.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_set_priority.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_set_scheduler.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_task_suspend and rtems_task_resume.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_wake_after.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_task_wake_when.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_timer_create and rtems_timer_fire_after.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_timer_create and rtems_timer_cancel.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_timer_create and rtems_timer_delete.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_timer_create and rtems_timer_reset.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_timer_create and rtems_timer_server_fire_after.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with a call to rtems_timer_initiate_server.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_timer_create and rtems_timer_server_fire_when.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with calls to rtems_timer_create and rtems_timer_fire_when.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_USER_EXTENSIONS defined to one and a call to rtems_extension_create.
The system shall provide a benchmark program to show the static memory usage of a basic application configuration with CONFIGURE_MAXIMUM_USER_EXTENSIONS defined to one and calls to rtems_extension_create and rtems_extension_delete.