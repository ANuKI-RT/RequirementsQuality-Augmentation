[
    [
        "RTT",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython are defined as a subset of Python 3.4 with some limitations."
    ],
    [
        "RTT",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython are defined as a subset of Python 3.4, with some restrictions."
    ],
    [
        "RTT",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython is defined as a subset of Python 3.4, with a few limitations"
    ],
    [
        "RTT",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython is defined as a subset of Python 3.4, with some restrictions."
    ],
    [
        "RTT",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython are defined as a subset of Python 3.4, with a few limitations"
    ],
    [
        "RTT",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython is defined as a subset of Python 3.4 with some limitations."
    ],
    [
        "RTT",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython is defined as a subset of Python 3.4, with some limitations."
    ],
    [
        "RTT",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython are defined as a subset of Python 3.4, with some limitations."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following built in types as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following built-in types as defined in Python 3.4: bool int float str object supertype"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following build-in types as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following built-in types as defined by Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython should support the following built-in types as defined in Python 3.4: bool int float str object super type."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following built-in types as defined in Python 3.4: bool int float str object super type."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following built in types as defined in Python 3.4: bool int float str object super type."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython should support the following built-in types as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following built-in types, as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following built-in types defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython shall support the following built-in types as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython will support the following built-in types as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following build-in types as defined in Python 3.4: bool int float str object super type."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following built-in types as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following integrated types as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following built-in types defined in Python 3.4: bool int float str object super type."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython should support the following built-in types, as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "MicroPython supports the following integrated types, as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython supports the following built-in types, as defined in Python 3.4: Bytearray Bytes Tuple Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython supports the following build-in types as defined in Python 3.4: Bytearray Bytes Tupel Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types as defined in Python 3.4: Bytearray Bytes Tupel Dict list"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types, as defined in Python 3.4: Bytearray Bytes Tuple Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types as defined in Python 3.4: Bytearray bytes tuples list"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types, as defined in Python 3.4: Bytearray bytes tuples list"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types as defined in Python 3.4: Bytearray Bytes Tuple Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython shall support the following built-in types as defined in Python 3.4: Bytearray Bytes Tupel Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types as defined in Python 3.4: Byte array bytes tuples list"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython supports the following built-in types as defined in Python 3.4: Bytearray Bytes Tupel Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython supports the following built-in types, as defined in Python 3.4: Bytearray Bytes Tupel Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython supports the following built-in types as defined in Python 3.4: Bytearray Bytes Tuple Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython supports the following built-in types defined in Python 3.4: Bytearray Bytes Tupel Dict List."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types, as defined in Python 3.4: Bytearray Bytes Tupel Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types as defined in Python 3.4: Bytearray Bytes Tupel Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython supports the following built-in types defined in Python 3.4: Bytearray Bytes Tupel Dict List"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types as defined in Python 3.4: Bytearray bytes tuple list"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types as defined in Python 3.4: bytearray bytes tuples list"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython should support the following built-in types as defined in Python 3.4: Bytearray Bytes Tupel Dict List."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython should support the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython should support the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate map."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types as defined by Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate Map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython will support the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython should support the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate Map."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython is supposed to support the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate Map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython should support the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate Map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython should support the following built-in types, as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following build-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types, as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types defined in Python 3.4: Filter Memoryview Set Range Reverse Zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types as defined by Python 3.4: Filter Memoryview Set Range Reverse zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython should support the following built-in types, as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate Map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython is supposed to support the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types defined in Python 3.4: Filter Memoryview Set Range Reverse zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types, as defined in Python 3.4: Filter Memoryview Set Range Reverse zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython will support the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate Map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types as defined by Python 3.4: Filter Memoryview Set Range Reverse Zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate Map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types, as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate Map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip enumerate map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map   ",
        "MicroPython supports the following built-in types as defined in Python 3.4: Filter Memoryview Set Range Reverse Zip Enumerate Map"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number according to object instance"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable true bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isexample (obj)"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if all values in iterable true bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isinstance (obj,"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if all values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isexample (obj,"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isexample (obj)"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if all values in iterable true bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isexample (obj,"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- binary format number chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isinstance ("
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isinstance (obj)"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isexample ("
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable true bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object instance"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- binary format number chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object instance"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if all values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isinstance (obj,"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isinstance ("
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if all values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isinstance (obj,"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number according to object isinstance ("
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable true bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number according to object instance"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isinstance (obj)"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable true bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isinstance ("
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable true bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object isinstance (obj)"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython supports the following built-in functions as defined in Python 3.4: abs (x) -- absolute value all (iterable) -- true if all values in iterable are all (iterable) -- true if any values in iterable True bin (x) -- format number in binary representation chr (x) -- characters corresponding to value x dir ([obj]) -- list of attributes in object divmod (x, y) -- a tuple with division and modulus globals () -- dictionary of global objects hasattr (obj, attr) -- check for an attribute hash (obj) -- hash value of an object hex (x) -- format number in hexadecimal representation id (obj) -- unique number corresponding to object instance"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the following built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError Overflow Error ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the following built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the following built-in exception hierarchy as defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError Unicode Error"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built-in exception hierarchy as defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the following built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration Syntax Error IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration Syntax Error IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError Overflow Error ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError Overflow Error ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the following exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError."
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError Overflow Error ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration SyntaxError IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython supports the built-in exception hierarchy defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemException ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EOFError ImportError LookupError IndexError KeyError MemoryError NameError OSError RuntimeError NotImplementedError StopIteration Syntax Error IndentationError TypeError ValueError UnicodeError"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports the following classes, as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython will support the following classes as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython shall support the following classes as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports the following classes as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports the following classes as defined in Python 3.4: classmethod static method"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports the following classes as defined by Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports classes as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports the following classes defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython should support the following classes as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports following classes as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython should support the following classes, as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports the following classes as defined in Python 3.4: classmethod staticmethode"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports the following classes as defined by Python 3.4: classmethod staticmethode"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython supports the following classes as defined in Python 3.4: clasmethod staticmethod"
    ],
    [
        "RTT",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython should support the following classes as defined in Python 3.4: classmethod staticmethod."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions in the gc module, as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions of the gc module, as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython should support the following functions in the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions in the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions of the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions in the gc module, as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions from the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions of the module gc as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython should support the following functions of the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions from the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython should support the following functions of the gc module, as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions of the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions in the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions of the gc module, as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython supports the following functions from the gc module, as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython should support the following functions of the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "MicroPython shall support the following functions of the gc module as defined in Python 3.4: gc.collect () gc.disable () gc.enable () gc.isenabled () gc.mem _ free () gc.mem _ alloc ()"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. On completion with sys.exita SystemExit, the exception is increased and the C function that starts the virtual machine execution returns the given code value bitwise ORed with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased, and the C function that starts the virtual machine execution returns the specified code value bitwise ORed with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. On completion with sys.exita SystemExit, the exception is increased, and the C function that starts the virtual machine execution returns the given code value bitwise ORed with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the virtual machine execution returns the given code value bitwise ORed with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. On completion with sys.exita SystemExit, the exception is increased, and the C function that starts the virtual machine execution returns the specified code value bitwise ORed with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. On completion with sys.exita SystemExit, the exception is increased and the C function that starts the virtual machine execution returns the specified code value bitwise with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. On completion with sys.exita SystemExit, the exception is increased and the C function that starts the virtual machine execution returns the specified code value bitwise ORed with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the virtual machine execution returns the specified code value bitwise with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased, and the C function that starts the virtual machine execution returns the specified code value bitwise with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the execution of the virtual machine returns the given code value bitwise with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the execution of the virtual machine returns the given code value bitwise ORed with 128"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the Virtual Machine execution returns the specified code value bitwise with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased, and the C function that starts the virtual machine execution returns the given code value bitwise ORed with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the Virtual Machine execution returns the given code value bitwise with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the Virtual Machine execution returns the given code value bitwise with 128"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. On completion with sys.exita SystemExit, the exception is increased and the C function that starts the virtual machine execution returns the given code value bitwise with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the execution of the virtual machine returns the specified code value bitwise ORed with 128"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the Virtual Machine execution returns the specified code value bitwise with 128"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the virtual machine execution returns the given code value bitwise with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased and the C function that starts the virtual machine execution returns the specified code value bitwise ORed with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.",
        "MicroPython supports the following function from the sysas module defined in Python 3.4: sys.exit ([code]) If the code argument is missing, the default value hall is taken. Upon completion with sys.exita SystemExit, the exception is increased, and the C function that starts the virtual machine execution returns the given code value bitwise with 128."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the Python 3.4 defined modular array: array.array (typecode [, initialiser])."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the Python 3.4 defined modular array: array.array (typecode [, initialiser])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython should support the following function from the modular array defined in Python 3.4: array.array (typecode [, initialiser])."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython should support the following function from the module array defined in Python 3.4: array.array (typecode [, initialiser])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the modular array defined in Python 3.4: array.array (typecode [, initializer])."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython should support the following function from the modular array defined in Python 3.4: array.array (typecode [, initialiser])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the Modularrayas defined in Python 3.4: array.array (Typecode [, Initializer])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython should support the following function from the module array defined in Python 3.4: array.array (typecode [, initialiser])."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython should support the following function from the Python 3.4 defined modular array: array.array (typecode [, initialiser])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the modular array defined in Python 3.4: array.array (typecode [, initializer])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the Modularrayas defined in Python 3.4: array.array (typecode [, initializer])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython should support the following function from the modular array defined in Python 3.4: array.array (typecode [, initialiser]):"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the modularrayas defined in Python 3.4: array.array (typecode [, initialiser])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the modular array defined in Python 3.4: array.array (typecode [, initialiser])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the modularrayas defined in Python 3.4: array.array (typecode [, initializer])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the Modularrayas defined in Python 3.4: array.array (typecode [, initialiser])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython should support the following function from the modularrayas defined in Python 3.4: array.array (typecode [, initialiser])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the module array defined in Python 3.4: array.array (typecode [, initialiser])"
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the modular array defined in Python 3.4: array.array (typecode [, initialiser])."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the modularrayas defined in Python 3.4: array.array (typecode [, initialiser])."
    ],
    [
        "RTT",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython supports the following function from the module array defined in Python 3.4: array.array (typecode [, initialiser])."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollections module as defined in Python 3.4 as collections: ucollections.namedtuple."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions in the ucollectionsmodule as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython should support the following functions in the ucollectionsmodule as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollections module as defined in Python 3.4 as collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions of the ucollections module as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollectionsas module defined in Python 3.4 as collections: ucollections.namedtuple."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython should support the following functions from the ucollectionsmodule as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollectionsas module defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollectionsmodule as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollections module as defined in Python 3.4 under the name collections: ucollections.namedtuple."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollectionsas module as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollectionsas module defined in Python 3.4 as collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions of the ucollectionsmodule as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following features of the ucollectionsmodule as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython should support the following functions from the ucollectionsmodule, as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollectionsmodule as defined in Python 3.4 as collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython should support the following functions from the ucollectionsmodule as defined in Python 3.4 under the name collections: ucollections.namedtuple."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions of the ucollections module as defined in Python 3.4 under the name collections: ucollections.namedtuple."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollections module, as defined in Python 3.4 as collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions of the ucollectionsmodule as defined in Python 3.4 as collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions from the ucollections module as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython should support the following functions from the ucollections module as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions in the ucollectionsas module defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython supports the following functions in the ucollections module as defined in Python 3.4 under the name collections: ucollections.namedtuple"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions of the Python 3.4 defined module: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions of the Python 3.4 module: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions of the module defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions of the mathas module defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following features from the mathas module defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions from the module mathas defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions in the Python 3.4 module: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions of the module defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions in the mathas module defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following features of the mathas module defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions of the module mathas defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions of the mathas module as defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following features of the module defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions from the mathas module defined in Python 3.4: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)",
        "MicroPython supports the following functions of the Python 3.4 module: e acos (x) frexp (x) pi asin (x) ldexp (x, i) sqrt (x) atan (x) modf (x) pow (x, y) atan2 (y, x) isfinite (x) exp (x) ceil (x) isinf (x) log (x [, base]) copysign (x, y) isnan (x) cos (x) fabs (x) trunc (x) sin (x) floor (x) radians (x) tan (x) fmod (x, y) degrees (x)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions from the modules defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions of the module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset,...)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions from the Python 3.4 module structures: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions of module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions from the module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions of the module structure defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions of the Python 3.4 module structure: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions of the modular structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset,...)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions of the module structure defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset,...)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions from module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions in the module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset,...)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions in the module structure defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following features of the module structure defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions from module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions of the module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions in the module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following module structure functions defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions of module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset,...)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions from the module structure defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions from the Python 3.4 module structures: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)",
        "MicroPython supports the following functions from the module structures defined in Python 3.4: calcsize (fmt) pack (fmt,...) pack _ into (fmt, buf, offset,...) unpack (fmt, buf) unpack _ from (fmt, buf, offset)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions of the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython should support the following functions from the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython should support the following functions from the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions from the Python 3.4 binasciias module: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following features from the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions in the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython should support the following functions of the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions from the Python 3.4 module binascien: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions of the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions from the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions from the module binaries defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython should support the following functions from the Python 3.4 binasciias module: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions from the Python 3.4 defined module binascien: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions in the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython should support the following functions in the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions from the module binary defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions from the Python 3.4 binasciias module: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)."
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions from the Python 3.4 module binary: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports following functions from the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)"
    ],
    [
        "RTT",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython supports the following functions from the binasciias module defined in Python 3.4: hexlify (data) unhexlify (hexstr) a _ base64 (string) b _ base64 (data)."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function will result in a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment that is attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap"
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of C stack used. micropython.pystack _ use () Returns the current amount of Python stack used. This function is only available if the virtual machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlock the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of C stack used. micropython.pystack _ use () Returns the current amount of Python stack used. This function is only available if the virtual machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap"
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of C stack used. micropython.pystack _ use () Returns the current amount of Python stack used. This function is only available if the Virtual Machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlock the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of C stack used. micropython.pystack _ use () Returns the current amount of Python stack used. This function is only available if the virtual machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the virtual machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine was compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the virtual machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of C stack used. micropython.pystack _ use () Returns the current amount of Python stack used. This function is only available if the Virtual Machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function will result in a MemoryError exception. micropython.heap _ unlock () Unlock the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment that is attempted after calling this function will result in a MemoryError exception. micropython.heap _ unlock () Unlocks the heap"
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function will result in a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of C stack used. micropython.pystack _ use () Returns the current amount of Python stack used. This function is only available if the Virtual Machine was compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlock the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of C stack used. micropython.pystack _ use () Returns the current amount of Python stack used. This function is only available if the Virtual Machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlock the heap"
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of C stack used. micropython.pystack _ use () Returns the current amount of Python stack used. This function is only available if the Virtual Machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlock the header."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine is compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function will result in a MemoryError exception. micropython.heap _ unlock () Unlock the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of the C stack used. micropython.pystack _ use () Returns the current amount of the Python stack used. This function is only available if the Virtual Machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that memory y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlocks the heap."
    ],
    [
        "RTT",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "MicroPython provides the following functions to the micropython.heap _ unlock () module: micropython.stack _ use () Returns the current amount of C stack used. micropython.pystack _ use () Returns the current amount of Python stack used. This function is only available if the virtual machine has been compiled in a configuration that uses a separate stack for Python function calls. micropython.heap _ lock () Locks the heap so that Memor y cannot be assigned. Any assignment attempted after calling this function triggers a MemoryError exception. micropython.heap _ unlock () Unlock the heap."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython should make it possible to use customized modules developed in C"
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython should allow the use of custom modules developed in C"
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython is intended to enable the use of custom modules developed in C."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython will allow the use of custom modules developed in C"
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython is designed to allow the use of custom modules developed in C"
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython is designed to allow the use of custom modules developed in C."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython should allow to use customized modules developed in C."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython will allow the use of custom modules developed in C."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython is designed to enable the use of custom modules developed in C."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython is designed to enable the use of custom modules developed in C"
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython should make it possible to use custom modules developed in C"
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython should make it possible to use custom modules developed in C."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython will enable the use of custom modules developed in C."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython should allow the use of custom modules developed in C."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython to enable the use of custom modules developed in C"
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython should enable the use of custom modules developed in C."
    ],
    [
        "RTT",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython should allow to use custom modules developed in C."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specified address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified), and the MicroPython Virtual Machine must not modify or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode ends ex ecution, the function returns the return value (0 if no error code is specified)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specified address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified) and the MicroPython Virtual Machine must not change or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return code (0 if no error code is specified) and the MicroPython Virtual Machine must not modify or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is given)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return code (0 if no error code is specified), and the MicroPython Virtual Machine is not allowed to change or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython byte code at a specific address in memory. If the byte code expires, the function returns the return value (0 if no error code is specified)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return code (0 if no error code is specified), and the MicroPython Virtual Machine must not modify or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified) and the MicroPython Virtual Machine is not allowed to modify or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified), and the MicroPython Virtual Machine must not change or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return code (0 if no error code is specified) and the MicroPython Virtual Machine must not change or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a particular address in memory. If the bytecode ends ex ecution, the function returns the return value (0 if no error code is specified)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return code (0 if no error code is specified), and the MicroPython Virtual Machine must not change or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified), and the MicroPython Virtual Machine is not allowed to change or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specified address in memory. If the bytecode ends ex ecution, the function returns the return value (0 if no error code is specified)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified) and the MicroPython Virtual Machine is not allowed to change or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start execution of the MicroPython bytecode at a specific address in memory. If the bytecode ends ex ecution, the function returns the return value (0 if no error code is specified)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified) and the MicroPython Virtual Machine must not modify or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a particular address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified), and the MicroPython Virtual Machine must not modify or remove the bytecode."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython byte code at a specific address in memory. If the byte code ends ex ecution, the function returns the return value (0 if no error code is specified)."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "The MicroPython Virtual Machine provides a C function to start the execution of the MicroPython bytecode at a specific address in memory. If the bytecode expires, the function returns the return value (0 if no error code is specified) .The MicroPython Virtual Machine must not modify or remove the bytecode."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it will stop and override a special exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it stops and cancels a certain exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it stops and cancels a special exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it will stop and override a certain exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine is unable to allocate the required memory during execution, it will stop and remove a certain exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it will stop and remove a specific exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it will stop and remove a special exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it will stop and highlight a certain exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine is unable to allocate the required memory during execution, it stops and cancels a special exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it stops and highlights a specific exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine is unable to allocate the required memory during execution, it will stop and remove a special exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it stops and highlights a certain exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine is unable to allocate the required memory during execution, it will stop and highlight a specific exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it will stop and highlight a specific exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine is unable to allocate the required memory during execution, it will stop and remove a specific exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution, it will stop and remove a certain exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine is unable to allocate the required memory during execution, it stops and highlights a specific exception."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code where the exception was raised."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a certain error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was called."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not detected by the MicroPython bytecode itself), it returns a specific error code and provides a means to determine the line number in the MicroPython source code in which the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "If the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was called."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was invoked."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to determine the line number in the MicroPython source code where the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a certain error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to determine the line number in the MicroPython source code in which the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "If the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code where the exception was raised."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a certain error code and provides a means to retrieve the line number in the MicroPython source code where the exception was raised."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was called."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was raised."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "If the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to determine the line number in the MicroPython source code in which the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "If the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a certain error code and provides a means to determine the line number in the MicroPython source code in which the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a certain error code and provides a means to determine the line number in the MicroPython source code in which the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not detected by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a certain error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was raised."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "If the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code in which the exception was triggered."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code where the exception was called."
    ],
    [
        "RTT",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "When the MicroPython Virtual Machine catches an exception du ring execution (which is not captured by the MicroPython bytecode itself), it returns a specific error code and provides a means to retrieve the line number in the MicroPython source code where the exception was triggered."
    ],
    [
        "RTT",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The MicroPython language should support object orientation, as defined in Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The language MicroPython should support object orientation as defined in Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The MicroPython language should support object orientation as defined in Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The language MicroPython should support object orientation as defined in Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The MicroPython language is intended to support object orientation as defined in Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The MicroPython language should support object orientation, as defined in Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The language MicroPython should support object orientation, as defined in Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The MicroPython language should support object orientation as defined in Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The MicroPython language is designed to support object orientation as defined in Python 3.4"
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython Cross-Compiler is provided, which creates a bytecode file with the extension .mpy from a given MicroPython script, which is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided that generates a bytecode file with the extension .mpy from a given MicroPython script, which is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython Cross-Compiler is provided, which generates a bytecode file with .mpy extension from a given MicroPython script that is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided which generates a bytecode file with the extension .mpy from a given MicroPython script that is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided, which generates a bytecode file with the extension .mpy from a given MicroPython script, which is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided which generates a bytecode file with the extension .mpy from a given MicroPython script which is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided that generates a bytecode file with .mpy extension from a given MicroPython script that is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided, which creates a bytecode file with the extension .mpy from a given MicroPython script that is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided that generates a bytecode file with the extension .mpy from a given MicroPython script that is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided, which generates a bytecode file with .mpy extension from a given MicroPython script, which is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided which generates a bytecode file with .mpy extension from a given MicroPython script that is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided that generates a bytecode file with .mpy extension from a given MicroPython script, which is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython Cross-Compiler is provided which generates a bytecode file with .mpy extension from a given MicroPython script that is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided, which generates a bytecode file with .mpy extension from a given MicroPython script, which is syntactically valid"
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython Cross-Compiler is provided that generates a bytecode file with the extension .mpy from a given MicroPython script, which is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython Cross-Compiler is provided, which generates a bytecode file with the extension .mpy from a given MicroPython script, which is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided which generates a bytecode file with .mpy extension from a given MicroPython script, which is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided, which generates a bytecode file with the extension .mpy from a given MicroPython script that is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided, which generates a bytecode file with .mpy extension from a given MicroPython script that is syntactically valid."
    ],
    [
        "RTT",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler is provided which generates a bytecode file with the extension .mpy from a given MicroPython script, which is syntactically valid."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The software development environment provides a tool for calculating a given byte code, the ISO checksum as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file attached to the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file appended with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The software development environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file attached to the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file, which is appended with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file attached to the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file that is attached to the ISO checksum (2 bytes)"
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file attached with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file, which is appended with the ISO checksum (2 Bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file appended with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file appended with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The software development environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file that is attached to the ISO checksum (2 bytes)"
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given bytecode, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file, which is appended with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file, which is appended with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file attached to the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file attached to the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file attached to the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file appended with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file, which is appended with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The software development environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and generates a .bin file with the contents of the .mpy file attached to the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The Software Development Environment provides a tool for calculating a given byte code, the ISO checksum, as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file, which is appended with the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "The software development environment provides a tool for calculating a given byte code, the ISO checksum as defined in Appendix A.2 of [RD03]. The tool takes a .mpy file as input and creates a .bin file with the contents of the .mpy file attached to the ISO checksum (2 bytes)."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the given script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid syntax, in which case no bytecode file may be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid syntax. In this case, no bytecode file may be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid syntax. In this case, no bytecode file must be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid syntax. In this case, no bytecode file is created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid syntax. In this case, no bytecode file may be created"
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid syntax, in which case no bytecode file may be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid file, in which case no bytecode file may be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler will report an error indicating the first invalid syntax, in which case no bytecode file will be generated."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid file. In this case, no bytecode file must be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid file. In this case, no bytecode file may be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler will report an error indicating the first invalid syntax, in which case no bytecode file may be generated."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler will report an error indicating the first invalid syntax, in which case no bytecode file may be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid syntax, in which case no bytecode file may be created"
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler will report an error indicating the first invalid syntax, in which case no bytecode file will be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid syntax, in which case no bytecode file will be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid file, in which case no bytecode file must be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler reports an error indicating the first invalid syntax, in which case no bytecode file is created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler will report an error indicating the first invalid file. In this case, no bytecode file may be created."
    ],
    [
        "RTT",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "If the specified script has an invalid syntax, the MicroPython cross-compiler will report an error indicating the first invalid file, in which case no bytecode file may be created."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython Virtual Machine, with semantics specified by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython Virtual Machine, with semantics determined by the MicroPython source code."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code created by the MicroPython cross-compiler is executed by the MicroPython Virtual Machine, with semantics specified by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython virtual machine, with semantics determined by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross compiler is executed by the MicroPython Virtual Machine, with semantics specified by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython Virtual Machine, with semantics specified by the MicroPython source code."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython virtual machine, with the semantics specified by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython Virtual Machine, specifying the semantics by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython Virtual Machine, with the semantics specified by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython Virtual Machine, with semantics determined by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython Virtual Machine, with the semantics determined by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython virtual machine, with semantics specified by the MicroPython source script."
    ],
    [
        "RTT",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "After loading into memory, the byte code generated by the MicroPython cross-compiler is executed by the MicroPython Virtual Machine, with semantics defined by the MicroPython source script."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import instructions with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a pre-processing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and creates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, unless these modules are C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a pre-processing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, unless these modules are C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a pre-processing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a pre-processing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import instructions with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided these modules are not C extensions. This process is recursive if the imported modules themselves contain import statements."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and creates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a pre-processing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import instructions with the contents of the corresponding MicroPython source files, unless these modules are C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, unless these modules are C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a pre-processing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and creates a semantically equivalent MicroPython script by replacing import instructions with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and creates a semantically equivalent MicroPython script by replacing import instructions with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and creates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, unless these modules are C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a pre-processing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and creates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and creates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions. This process is recursive if the imported modules themselves contain import statements."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions. This process is recursive if the imported modules themselves contain import instructions."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and generates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions. This process is recursive if the imported modules themselves contain import statements."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a specific Micr oPython script into input and creates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided these modules are not C extensions. This process is recursive if the imported modules themselves contain import statements."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment provides a preprocessing tool called \"Import Expander.\" The Import Expander takes a particular Micr oPython script into input and creates a semantically equivalent MicroPython script by replacing import statements with the contents of the corresponding MicroPython source files, provided that these modules are not C extensions."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool reports an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as from the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in one of these two flavors, then the tool reports an error stating that it cannot handle such a case. For the first taste, to limit complexity, it is accepted to treat the m1 import a, b as from the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit complexity, it is accepted to treat the m1 import a, b as from the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat m1 import a, b as from m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as from the m1 import *"
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as from the m1 import. *"
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat m1-Import a, b as from m1-Import."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat m1 import a, b as from m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in one of these two flavors, then the tool reports an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as from the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, then the tool reports an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as from the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit complexity, it is accepted to treat m1 import a, b as from m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in one of these two flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as from the m1 import."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in one of these two flavors, then the tool reports an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in one of these two flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat m1 import a, b as from m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit complexity, it is accepted to treat the m1 import a, b as from the m1 import *"
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as from the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in one of these two flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as from the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in either of these flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted that the m1 import treats a, b as from the m1 import *."
    ],
    [
        "RTT",
        "The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import  or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import *",
        "The Import Expander must be able to handle both flavors of the MicroPython import: from the m1 import < unk > or Import m2, m3 If this is found as a keyword in one of these two flavors, the tool must report an error stating that it cannot handle such a case. For the first taste, to limit the complexity, it is accepted to treat the m1 import a, b as from the m1 import *"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias, so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias, so that the objects of m can also be referenced in scope S2. 2. If from m import < unk > is found in scope S2, while from m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation, it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation, it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation, it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation, it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias, so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation, it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias, so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias, so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias, so that the objects of m can also be referenced in scope S2. 2. If from m import < unk > is found in scope S2, while from m import < unk > already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If from m import < unk > is found in scope S2, while from m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If from m import < unk > is found in scope S2, while from m import < unk > already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation, it applies the following rules: 1. If Import m is found in scope S2, while Import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If from m import < unk > is found in scope S2, while from m import < unk > is already in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2 and S"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation, it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias, so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias, so that the objects of m can also be referenced in scope S2. 2. If import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2  S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import  is found in scope S2 while from m import  has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2  S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import   flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.    ",
        "The Import Expander detects if a module in the port statement refers to an already imported module, either directly or through cascaded imports; in such a situation, it applies the following rules: 1. If import m is found in scope S2, while import m has already occurred in scope S1, then x, if S2 = S1, then the last import statement is skipped, x, if S2  S1, then the import statement in S2 is replaced by an assignment that creates an alias so that the objects of m can also be referenced in scope S2. 2. If m import < unk > is found in scope S2, while m import < unk > has already occurred in scope S1, then x, if S2 = S1, then the latest import statement is skipped, x, if S2 and"
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules it analyzes the importing MicroPython procedure and copies only the subset of variable assignments that are actually used in this procedure."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules, it analyzes the importing MicroPython procedure and copies only the subset of variable assignments that are actually used in this method."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": For a given list of modules, it analyzes the importing MicroPython procedure and copies only the subset of variable assignments that are actually used in this procedure."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules it should analyze the importing MicroPython procedure and copy only the subset of variable assignments that are actually used in this procedure."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules, it should analyze the importing MicroPython procedure and copy only the subset of assignments of variables that are actually used in this procedure."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules, it should analyze the importing MicroPython procedure and copy only the subset of variable assignments that are actually used in this process."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules, it should analyze the importing MicroPython procedure and copy only the subset of variable assignments that are actually used in this procedure."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules, it should analyze the importing MicroPython procedure and copy only the subset of assignments of variables actually used in this procedure."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules, it should analyze the importing MicroPython procedure and copy only the subset of variable assignments that are actually used in this method."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules, it analyzes the importing MicroPython procedure and copies only the subset of variable assignments that are actually used in this procedure."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules, it should analyze the importing MicroPython procedure and copy only the subset of variable assignments actually used in this procedure."
    ],
    [
        "RTT",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "The Import Expander should be able to perform an \"intelligent extension\": for a given list of modules, it analyzes the importing MicroPython procedure and copies only the subset of variable assignments actually used in this procedure."
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all the names that have been preserved by the \"intelligent extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all names that have been preserved by the \"intelligent extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The import expander should be able to report all names that have been preserved by the \"intelligent expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander will be able to report all names that have been retained by the \"intelligent extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all names that have been preserved by the \"smart expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all the names that have been preserved by the \"intelligent expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all the names that have been retained by the \"smart extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander will be able to report all the names that have been retained by the \"smart extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all names that have been retained by the \"intelligent expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all the names that have been retained by the \"smart expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all names that have been preserved by the \"smart extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander will be able to report all the names that have been retained by the \"intelligent extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report any names that have been retained by the \"smart expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander will be able to report all names that have been retained by the \"smart extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The import expander should be able to report all names that have been retained by the \"smart extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The import expander should be able to report all names that have been preserved by the \"intelligent extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The import expander should be able to report all names that have been retained by the \"intelligent extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all names that have been retained by the \"smart expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all names that have been preserved by the \"intelligent expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all names that have been retained by the \"intelligent extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The import expander should be able to report all names that have been retained by the \"smart expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander will be able to report any names that have been retained by the \"smart extension.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The import expander should be able to report all names that have been preserved by the \"smart expansion.\""
    ],
    [
        "RTT",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander should be able to report all names that have been retained by the \"smart extension.\""
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a particular MicroPython procedure and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a particular MicroPython procedure and possibly detect some bugs."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a particular MicroPython procedure and potentially detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a specific MicroPython procedure and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The Software Development Environment provides a static analysis tool to report violations of the encoding standard for a particular MicroPython process and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a given MicroPython process and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a given MicroPython method and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The Software Development Environment provides a static analysis tool to report violations of the encoding standard for a particular MicroPython method and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a given MicroPython procedure and potentially detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a particular MicroPython method and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to detect violations of the encoding standard for a given MicroPython procedure and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to detect violations of the encoding standard for a particular MicroPython procedure and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The Software Development Environment provides a static analysis tool to report violations of the encoding standard for a specific MicroPython procedure and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The Software Development Environment provides a static analysis tool to detect violations of the encoding standard for a particular MicroPython process and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a particular MicroPython process and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment provides a static analysis tool to report violations of the encoding standard for a given MicroPython procedure and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The Software Development Environment provides a static analysis tool to report violations of the encoding standard for a particular MicroPython procedure and possibly detect some errors."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to display the call tree of a particular MicroPython method."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The software development environment provides a static analysis tool to display the call tree of a specific MicroPython method."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The software development environment provides a static analysis tool to display the call tree of a particular MicroPython procedure."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool for displaying the call tree of a specific MicroPython procedure."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool for displaying the call tree of a given MicroPython method."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The software development environment provides a static analysis tool for displaying the call tree of a particular MicroPython method."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to display the call tree of a specific MicroPython method."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool for displaying the call tree of a particular MicroPython method."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to view the call tree of a specific MicroPython procedure."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to display the call tree of a specific MicroPython procedure."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to display the call tree of a given MicroPython procedure."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to display the call tree of a given MicroPython method."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to display the call tree of a given MicroPython process."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The software development environment provides a static analysis tool to display the call tree of a specific MicroPython procedure."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The software development environment provides a static analysis tool to display the call tree of a particular MicroPython method."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to view the call tree of a particular MicroPython procedure."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The software development environment provides a static analysis tool to visualize the call tree of a particular MicroPython method."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to display the call tree of a particular MicroPython procedure."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment provides a static analysis tool to view the call tree of a given MicroPython method."
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory area starting with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr addresses. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region starting with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the given buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region starting with the address addr into the specified buffer. buf must be a byte array or an array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region originating from the addr address into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory addr"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr addresses. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region starting with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region beginning with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr addresses. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region beginning with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region starting with the address addr into the specified buffer. buf must be a byte array or an array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the given buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory area beginning with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region originating from the addr address into the specified buffer. buf must be a byte array or an array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory adres."
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region starting with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the given buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr addresses. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region beginning with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the given buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr addresses. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region originating from the addr address. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory addr"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region originating from the addr address into the specified buffer. buf must be a byte array or an array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory addr"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region starting with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr addresses. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory area starting with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory area starting with the address addr into the specified buffer. buf must be a byte array or an array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region originating from the addr address into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address. buf"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr address. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory region beginning with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the given buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython must provide the mem.read _ u32 (addr) module with the following functions: mem.read _ u32 (addr) Returns the 32-bit value to the specified addr addresses. addr must be word-ignited. mem.write _ u32 (addr, value) Write the value to the specified addr address. addr must be word-ignited. addr must be word-ignited. mem.read _ buf (addr, buf) Reads a memory area beginning with the address addr into the specified buffer. buf must be a byte array or array and its length must be a multiple of 4. mem.write _ buf (addr, buf) Write the specified buffer to the memory address"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is executed; the first virtual machine has an identifier of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script runs. The first virtual machine has an identifier of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is running, the first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for Multiprocessor Systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script runs. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer number as the identifier of the virtual machine in which this script is running. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for Multiprocessor Systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is executed; the first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is executed, the first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer number as the identifier of the virtual machine in which this script is running. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script runs. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for Multiprocessor Systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is running. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for Multiprocessor Systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script runs. The first virtual machine has an identifier of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for Multiprocessor Systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer number as the identifier of the virtual machine in which this script is running, the first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer number as the identifier of the virtual machine in which this script runs. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer number as the identifier of the virtual machine in which this script is running, the first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for Multiprocessor Systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script runs. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multi-processor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is running. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is executed. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is executed, the first virtual machine has an identifier of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is running, the first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer as the identifier of the virtual machine in which this script is running, the first virtual machine has an identifier of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for Multiprocessor Systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython provides the rtemsmodule with the following function: rtems.script _ id () Returns an integer number as the identifier of the virtual machine in which this script runs. The first virtual machine has an identification of 0. and the following objects (integer constants): DEFAULT _ ATTRIBUTES, WAIT, NO _ WAIT, SEARCH _ ALL _ NODES, SEARCH _ OTHER _ NODES, SEARCH _ LOCAL _ NODE. with the same meaning as defined in the Real-Time Executive for Multiprocessor Systems."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is satisfied. Max _ size is the maximum size of a message, in bytes. The attr attribute specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBU"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is met. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages that the queue can hold before it is satisfied. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults on rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is met. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults on rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is fulfilled. Max _ size is the maximum size of a message, in bytes. The attr attribute specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBU"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is fulfilled. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults on rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is satisfied. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is satisfied. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBUT."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is satisfied. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults on rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is met. Max _ size is the maximum size of a message, in bytes. The attr attribute specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBU"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages that the queue can hold before it is satisfied. Max _ size is the maximum size of a message, in bytes. The attr attribute specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBU"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages that the queue can hold before it is satisfied. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is satisfied. Max _ size is the maximum size of a message, in bytes. The attr attribute specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBU."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is satisfied. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults on rtems.DEFAULT _ ATTRIBUT."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "When MicroPython provides the rtems.queue module for creating and using message queues, it should provide the following functions: rtems.queue.create (name, count, max _ size, attr = rtems.DEFAULT _ ATTRIBUTES) Creates a new Real-Time Executive for Multiprocessor Systems queue and returns a queue object that can be used to send and receive messages on the queue. The name argument must be a string of four characters. Count is the maximum number of messages the queue can hold before it is fulfilled. Max _ size is the maximum size of a message, in bytes. The attr argument specifies the attributes of the queue and defaults to rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. The name argument must be a string of four chars long. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBU"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars long. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT _ ATTRIBUTES"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. The name argument must be a string of four chars long. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUTES"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBU."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT _ ATTRIBUTES."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphors and defaults to rtems.DEFAULT _ ATTRIBUTES"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUTES"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUTES"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBUT."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBU"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. The name argument must be a string of four chars long. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUTES."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars long. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUTES"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars long. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT _ ATTRIBUTES"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtems.DEFAULT _ ATTRIBUT."
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBU"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. The name argument must be a string of four chars long. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars long. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBU"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "MicroPython provides the rtems.sem module for creating and accessing Real-Time Executive for Multiprocessor Systems semaphore. It provides the following functions: rtems.sem.create (name, count = 1, attr = rtems.DEFAULT _ ATTRIBUTES, prio = 0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control simultaneous access to a resource. the name argument must be a string of four chars. count is the number of units that the initial semaphore holds (defaults to a unit). The attr argument specifies the attributes of the semaphore and default to rtemore s.DEFAULT _ ATTRIBUT"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method of stopping executing. task.get _ note (Note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkboxes and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of stopping executing. task.get _ note (Note _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of halting executing. task.get _ note (note _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkboxes and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of stopping executing. task.get _ note (hint _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method to interrupt execution. task.get _ note (note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method to interrupt executing. task.get _ note (note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of halting executing. task.get _ note (hint _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method to stop executing. task.get _ note (Note _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method to stop executing. task.get _ note (note _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of stopping executing. task.get _ note (note _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of halting execution. task.get _ note (Note _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method of stopping executing. task.get _ note (note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method to interrupt execution. task.get _ note (Note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method to interrupt executation. task.get _ note (Note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkboxes and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of stopping executing. task.get _ note (note _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method to interrupt executing. task.get _ note (Note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method to interrupt executation. task.get _ note (note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of halting execution. task.get _ note (note _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method to stop executing. task.get _ note (hint _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method of interrupting execution. task.get _ note (note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) because this is Python's default method of interrupting execution. task.get _ note (Note _ id) Take an integer"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of stopping executing. task.get _ note (Note _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of stopping executing. task.get _ note (hint _ id) Take an integer and"
    ],
    [
        "RTT",
        "MicroPython shall provide the module rtems.task with the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.",
        "MicroPython provides the rtems.task module with the following functions: task.wake _ when ((year, month, day, hour, minute, second). Take a tuple of fintegers that specify a da te and time. The script sleeps until that time. Appropriate C function: rtems task wake when (). task.wake _ after (checkmark) Take an integer that is a number of checkmarks and interrupt the script for that duration. Appropriate C function: rt ems task wake after (). Note: It is recommended to use time.sleep (sec) instead, because this is Python's default method of stopping executing. task.get _ note (Note _ id) Take an integer and use a"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below second. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float."
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float to"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (including), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float to the"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (including), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save the following items in the specified list: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the second. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float."
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) The month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save the following items in the specified list: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following elements: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the second. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float."
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float to the time."
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following elements: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy under seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float."
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (including), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float to the"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy under seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float."
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (including), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save the following items in the specified list: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy under seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) The month is in the range 12 (including), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save the following items in the specified list: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy under seconds. time.sleep (seconds) sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) The month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) The month is in the range 12 (including), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save the following elements in the specified list: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the second. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float."
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float to the epoch"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the second. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (including), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float."
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (including), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following elements: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float."
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) The month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following elements: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below the seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "MicroPython shall provide the module time, with the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()  Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.",
        "MicroPython provides the module time with the following functions: time.localtime () Returns a 6-tuple containing the following: (year, month, mday, hour, minute, second) Month is in the range 12 (inclusive), mday is in 11, hour is in 03, minute is in 09 and second is in 09. time.localtime _ into (lst) Save in the specified list the following items: (year, month, mday, hour, minute, second) The range of these values is the same as in the time.localtime function. time.time () Returns the number of seconds since the epoch as a float. Has an accuracy below seconds. time.sleep (seconds) Sleep for the specified number of seconds. Seconds can be a float,"
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its sub-modules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument that is the string corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function throws a Python OSError exception with a single argument corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument, which is the string corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its sub-modules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return value is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument that corresponds to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function throws a Python OSError exception with a single argument that is the string corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return value is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument that corresponds to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its sub-modules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return value is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument corresponding to the rtems _ status _ code character string."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument corresponding to the string corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function throws a Python OSError exception with a single argument corresponding to the rtems _ status _ code string."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its sub-modules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument that corresponds to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument corresponding to the rtems _ status _ code string."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument that is the string corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its sub-modules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return value is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function throws a Python OSError exception with a single argument corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its sub-modules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function triggers a Python OSError exception with a single argument corresponding to the rtems _ status _ code string."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its submodules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return value is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function throws a Python OSError exception with a single argument corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code.    ",
        "Each function provided by the rtems module and its sub-modules (see above) checks the returned status code of the underlying RTEM-S-C functions. If this return code is not Real-Time Executive for Multiprocessor Systems _ SUCCESSFULL, the function throws a Python OSError exception with a single argument that is the string corresponding to the rtems _ status _ code."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided that provides functions for ion editing, syntax checking, code completion, execution and debugging, for which the MicroPython script under development is aligned with a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided that provides functions for ion processing, syntax checking, code completion, execution, and debugging, for which the MicroPython script under development is aligned to a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided, which provides functions for ion processing, syntax checking, code completion, execution and debugging. For these functions, the MicroPython script in development is adapted to a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided, which provides functions for ion processing, syntax checking, code completion, execution and debugging. For these functions, the MicroPython script in development is aligned with a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided, which provides functions for ion processing, syntax checking, code completion, execution and debugging. For these functions, the MicroPython script under development is aligned with a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided, which provides functions for ion processing, syntax checking, code completion, execution and debugging. For these functions, the MicroPython script under development is adapted to a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided, which provides functions for ion processing, syntax checking, code completion, execution and debugging. For these functions, the MicroPython script under development is aligned to a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided that provides functions for ion processing, syntax checking, code completion, execution, and debugging, for which the MicroPython script under development is aligned with a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided that provides functions for ion processing, syntax checking, code completion, execution and debugging, for which the MicroPython script under development is adapted to a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided that provides functions for ion editing, syntax checking, code completion, execution and debugging, for which the MicroPython script under development is adapted to a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided that provides functions for ion processing, syntax checking, code completion, execution, and debugging, for which the MicroPython script under development is adapted to a Python 3.4 script."
    ],
    [
        "RTT",
        "Software Development Environment shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython script under development shall be assimilated to a Python 3.4 script.",
        "For the development of the MicroPython method, a software development environment is provided that provides functions for ion processing, syntax checking, code completion, execution, and debugging. For these functions, the MicroPython script under development is aligned with a Python 3.4 script."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with a simple means of invoking the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides an easy way for the user to invoke the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy), and the messages output by the cross-compiler must be visible in the Software Development Environment."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with an easy way to invoke the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy)"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with an easy way to invoke the MicroPython cross-compiler on any MicroPython method to create the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with an easy way to invoke the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides an easy way for the user to invoke the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides a simple means for the user to call the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with an easy way to invoke the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with a simple means to call the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides an easy way for the user to invoke the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy), and the messages output by the cross-compiler must be visible in the Software Development Environment."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with an easy way to invoke the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy), and the messages output by the cross-compiler must be visible in the Software Development Environment."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with an easy way to call the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides a simple means for the user to invoke the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with a simple means of invoking the MicroPython cross-compiler on any MicroPython method to create the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with an easy way to invoke the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy), and the messages output by the cross-compiler must be visible in the Software Development Environment."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with an easy way to invoke the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy)"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides a simple means for the user to invoke the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with a simple means of invoking the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy)."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment provides the user with an easy way to invoke the MicroPython cross-compiler on any MicroPython method to generate the associated bytecode file (extension .mpy), and the messages issued by the cross-compiler must be visible in the Software Development Environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander will be called automatically before the cross-compiler is called (pre-processing of the source code), and the messages output by the Import Expander will be visible in the software development environment"
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is called automatically before the cross-compiler is called (pre-processing of the source code), and the messages output by the Import Expander are visible in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the import expander will be called automatically before the cross-compiler (pre-processing of the source code) is called."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander will be called automatically before the cross-compiler (pre-processing of the source code) is called."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is called automatically before the cross-compiler is called (pre-processing of the source code)."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is automatically called before the cross-compiler is called (pre-processing of the source code) and the messages output by the Import Expander are displayed in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is automatically invoked before the cross-compiler is invoked (source code pre-processing)."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is called automatically before the cross-compiler (pre-processing of the source code) is called."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the import expander will be called automatically before the cross-compiler (pre-processing the source code) is called. Messages output by the import expander are visible in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is called automatically before the cross-compiler is called (pre-processing of the source code), and the messages output by the Import Expander are displayed in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is automatically called before the cross-compiler is called (pre-processing of the source code) and the messages output by the Import Expander are visible in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the import expander will be called automatically before the cross-compiler (pre-processing of the source code) is called. Messages output by the import expander are visible in the software development environment"
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the import expander is automatically called before the cross-compiler (pre-processing of the source code) is called. Messages output by the import expander are visible in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is called automatically before the cross-compiler is called (pre-processing of the source code) and the messages output by the Import Expander are displayed in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is automatically called before the cross-compiler is called (pre-processing of the source code), and the messages output by the Import Expander are displayed in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the import expander is automatically called before the cross-compiler (pre-processing the source code) is called."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the import expander is automatically called before the cross-compiler (pre-processing of the source code) is called."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is automatically called before the cross-compiler is called (pre-processing of the source code), and the messages output by the Import Expander are visible in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the import expander is automatically called before the cross-compiler (pre-processing the source code) is called. Messages output by the import expander are visible in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the import expander will be called automatically before the cross-compiler (pre-processing of the source code) is called. Messages output by the import expander are visible in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is called automatically before the cross-compiler is called (pre-processing of the source code) and the messages output by the Import Expander are visible in the software development environment."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is automatically invoked before the cross-compiler is invoked (pre-processing of the source code)"
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the Import Expander is automatically invoked before the cross-compiler is invoked (pre-processing the source code)."
    ],
    [
        "RTT",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the software development environment is configured in this way, the import expander is automatically called before the cross-compiler is called (pre-processing of the source code)."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The Software Development Environment provides an easy way to invoke the ISO checksum tool to create the .bin file for a given .mpy."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The software development environment provides an easy way to invoke the ISO checksum tool to create the .bin file for a given .mpy."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The software development environment provides an easy way to call the ISO checksum tool to generate the .bin file for a given .mpy file."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The software development environment provides an easy way to invoke the ISO checksum tool to generate the .bin file for a given .mpy."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The software development environment provides a simple way to call the ISO checksum tool to create the .bin file for a given .mpy file."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The Software Development Environment provides an easy way to invoke the ISO checksum tool to generate the .bin file for a given .mpy."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The Software Development Environment provides an easy way to call the ISO checksum tool to create the .bin file for a given .mpy file."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The software development environment provides an easy way to call the ISO checksum tool to create the .bin file for a given .mpy file."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The software development environment provides an easy way to invoke the ISO checksum tool to generate the .bin file for a given .mpy file."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The software development environment provides a simple way to call the ISO checksum tool to generate the .bin file for a given .mpy file."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The software development environment provides a simple way to invoke the ISO checksum tool to create the .bin file for a given .mpy."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The software development environment offers an easy way to call the ISO checksum tool to create the .bin file for a given .mpy file."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The Software Development Environment provides an easy way to invoke the ISO checksum tool to generate the .bin file for a given .mpy file."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The Software Development Environment provides an easy way to call the ISO checksum tool to generate the .bin file for a given .mpy file."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The Software Development Environment offers an easy way to load and execute a certain bytecode file on a certain LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The software development environment should provide a simple way to load and execute a given bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The software development environment should offer a simple way to load and execute a given bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The Software Development Environment provides an easy way to load and execute a specific bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The Software Development Environment offers an easy way to load and execute a specific bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The Software Development Environment provides a simple way to load and execute a specific bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The Software Development Environment provides an easy way to load and execute a certain bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The software development environment is designed to provide a simple way to load and execute a given bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The Software Development Environment offers a simple way to load and execute a specific bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The software development environment is intended to provide a simple way to load and execute a given bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The software development environment is intended to provide an easy way to load and execute a given bytecode file on a specific LEON2 target."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine Testsuite is to be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine Test Suite will be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine test suite will be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The test suite Virtual Machine will be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine test suite is to be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The test suite Virtual Machine shall be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine Test Suite should be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine Testsuite should be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine Test Suite is to be automated"
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The test suite Virtual Machine is to be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine Testsuite will be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The virtual machine test suite is to be automated."
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine Test-Suite is to be automated"
    ],
    [
        "RTT",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine Test Suite is to be automated."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine should have a minimum size of 200 KBytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must have a minimum size of 200 KBytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must have a minimum size that must not exceed 200 KBytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must have a minimum size that must not exceed 200 Kbytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must have a minimum size not exceeding 200 KByte."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must have a minimum size not exceeding 200 KBytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must have a minimum size not exceeding 200 Kbytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must be of a minimum size not exceeding 200 KBytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine should have a minimum size of no more than 200 KBytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine should have a minimum size not exceeding 200 kbytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must have a minimum size not exceeding 200 kbytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must be of a minimum size not exceeding 200 kbytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must have a minimum size that must not exceed 200 kbytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine should have a minimum size not exceeding 200 KBytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine should have a minimum size that must not exceed 200 KBytes."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine must have a minimum size that must not exceed 200 KByte."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross-compiler is designed to generate a byte code with minimal size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross-compiler should be designed to generate a bytecode with a minimum size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The cross-compiler of MicroPython should be designed to generate a byte code with a minimum size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython Cross-Compiler is designed to generate a byte code with minimal size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross-compiler should be designed to generate a byte code with minimum size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross compiler should be designed to generate a byte code with minimal size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross-compiler should be designed to generate a bytecode with minimal size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross-compiler is designed to generate a byte code with minimum size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross-compiler is designed to generate a bytecode with minimal size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The cross-compiler of MicroPython should be designed to generate a byte code with minimal size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The cross-compiler of MicroPython should be designed to generate a byte code with minimum size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross-compiler is designed to generate a byte code with a minimum size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross-compiler should be designed to generate a byte code with minimal size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The cross-compiler of MicroPython should be designed in such a way that it generates a byte code with minimum size."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "The MicroPython cross-compiler should be designed to generate a byte code with a minimum size."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine is designed to execute the byte code by striking a good compromise between memory consumption and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the bytecode by finding a good compromise between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine is designed to execute the byte code using a good trade-off between memory consumption and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython virtual machine should be designed to execute the byte code by finding a good compromise between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code using a good trade-off between memory usage and execution time. Minimizing memory usage should be a priority in this choice."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine is designed to execute the byte code by finding a good compromise between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code using a good trade-off between memory usage and execution time. In this choice, minimizing memory usage should be a priority."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code using a good trade-off between memory usage and execution time. In this choice, minimizing memory usage should be the priority."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine is designed to execute the byte code using a good trade-off between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the bytecode by striking a good compromise between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine is designed to execute the byte code by striking a good compromise between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code, finding a good compromise between memory consumption and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code and find a good compromise between memory consumption and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython virtual machine should be designed to execute the byte code using a good trade-off between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code using a good trade-off between memory usage and execution."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code by striking a good compromise between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code using a good trade-off between memory usage and execution time, and minimizing memory usage should be a priority in this choice."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code by finding a good compromise between memory consumption and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code using a good trade-off between memory consumption and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code by finding a good compromise between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code by striking a good compromise between memory consumption and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the bytecode and find a good compromise between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the bytecode and find a good compromise between memory consumption and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code and find a good compromise between memory usage and execution time."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "The MicroPython Virtual Machine should be designed to execute the byte code using a good trade-off between memory usage and execution time. In this choice, minimizing memory usage should take priority."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a specific target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The MicroPython cross-compiler source code and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The MicroPython cross-compiler source code and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (e.g. ROM \/ RAM size) or the selection of a specific target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account limitations of specific hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (e.g. ROM \/ RAM size) or the selection of a specific target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (such as ROM \/ RAM size) or the selection of a specific target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The MicroPython cross-compiler source code and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (such as ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account limitations of specific hardware targets (such as ROM \/ RAM size) or to select a specific trade-off for a specific target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (such as ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The MicroPython cross-compiler source code and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (such as ROM \/ RAM size) or the selection of a specific target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compilation chain must contain configuration parameters to take into account the limitations of specific hardware targets (e.g. ROM \/ RAM size) or the selection of a specific target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (e.g. ROM \/ RAM size) or to select a particular trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compilation chain must contain configuration parameters to take into account the limitations of specific hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (such as ROM \/ RAM size) or to select a specific trade-off for a specific target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account limitations of specific hardware targets (such as ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account limitations of specific hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a specific target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account constraints on specific hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The cross-compiler source code of MicroPython and a d \/ or compile chain must contain configuration parameters to take into account the limitations of specific hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compile chain must contain configuration parameters to accommodate constraints on certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compilation chain must contain configuration parameters to accommodate constraints on specific hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compilation chain must contain configuration parameters to accommodate limitations of certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compilation chain must contain configuration parameters to take into account limitations of certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compile chain must contain configuration parameters to take into account limitations of certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compile chain must contain configuration parameters to take into account constraints on certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compile chain must contain configuration parameters to take into account limitations of certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a specific target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compilation chain must contain configuration parameters to accommodate constraints on certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compilation chain must contain configuration parameters to accommodate constraints on certain hardware targets (such as ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compile chain must contain configuration parameters to accommodate constraints on certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a specific target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compile chain must contain configuration parameters to accommodate limitations of certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compilation chain must contain configuration parameters to accommodate constraints on certain hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a specific target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compile chain must contain configuration parameters to accommodate constraints on certain hardware targets (such as ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compilation chain must contain configuration parameters to take into account limitations of certain hardware targets (such as ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The source code of MicroPython Virtual Machine and \/ or the compile chain must contain configuration parameters to accommodate constraints on specific hardware targets (e.g. ROM \/ RAM size) or to select a specific trade-off for a particular target."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross-compiler (generation of byte code from the MicroPython script), a virtual machine (execution of the byte code)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross-compiler (production of bytecode from the MicroPython script), a virtual machine (execution of the bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross-compiler (generation of bytecode from the MicroPython script), and a virtual machine (execution of the bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of MicroPython script), a cross compiler (production of bytecode from MicroPython script), a virtual machine (execution of bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross compiler (generation of bytecode from the MicroPython script), a virtual machine (execution of the bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of MicroPython script), a cross-compiler (production of byte code from MicroPython script), a virtual machine (execution of byte code)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross-compiler (production of byte code from the MicroPython script), a virtual machine (execution of the byte code)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a virtual machine (execution of the bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross-compiler (production of bytecode from the MicroPython script), a virtual machine (execution of bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross-compiler (generation of bytecode from the MicroPython script), a virtual machine (execution of the bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross-compiler (production of bytecode from the MicroPython script), and a virtual machine (execution of the bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross-compiler (generation of bytecode from the MicroPython script), a virtual machine (execution of bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a virtual machine (execution of bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of a MicroPython script), a cross-compiler (production of bytecode from a MicroPython script), a virtual machine (execution of the bytecode)"
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of the MicroPython script), a cross compiler (production of bytecode from the MicroPython script), a virtual machine (execution of the bytecode)."
    ],
    [
        "RTT",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment consists of a software development environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), and a virtual machine (execution of bytecode)."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature that is outside the scope of the requirements defined in this document is disabled by C preprocessor instructions."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature outside the scope of the requirements defined in this document is disabled by C preprocessor instructions."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature that is outside the requirements defined in this document is disabled by C preprocessor directives."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language attribute outside the requirements defined in this document is disabled by C preprocessor directives."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature outside the scope of the requirements defined in this document is disabled by C preprocessor statements."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language attribute outside the scope of the requirements defined in this document is disabled by C preprocessor statements."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature outside the requirements defined in this document is disabled by C preprocessor directives."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature that is outside the requirements defined in this document is disabled by C preprocessor directive."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature that is outside the scope of the requirements defined in this document is disabled by C preprocessor directive."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature outside of the requirements defined in this document is disabled by C preprocessor directives."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature that is outside the scope of the requirements defined in this document is disabled by C preprocessor directives."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature outside the scope of the requirements defined in this document is disabled by C preprocessor directives."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature that is outside the scope of the requirements defined in this document is disabled by C preprocessor statements."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language attribute outside the scope of the requirements defined in this document is disabled by C preprocessor directives."
    ],
    [
        "RTT",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython Cross-Compiler and Virtual Machine, any language feature beyond the scope of the requirements defined in this document is disabled by C preprocessor directives."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1.bit model; floating-point numbers require heap assignment; 2.bit model; NaN boxes; floating-point numbers do not require heap assignment."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1.bit model; floating-point numbers require heap mapping; 2.bit model; NaN boxes; floating-point numbers do not require heap mapping."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1-bit model; floating point numbers require heap assignment; 2-bit model; NaN boxes; floating numbers do not require heap assignment."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for the representation of MicroPython objects: 1.bit model; floating point numbers require heap assignment; 2.bit model; NaN boxes; floating numbers do not require heap assignment."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1-bit model; floating-point numbers require heap assignment; 2-bit model; NaN boxes; floating-point numbers do not require heap allocation."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1-bit model; floating-point numbers require heap assignment; 2-bit model; NaN boxes; floating-point numbers do not require heap mapping."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1.Bit model; floating point numbers require heap assignment; 2.Bit model; NaN boxes; floating point numbers do not require heap assignment."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1-bit model; floating-point numbers require heap mapping; 2-bit model; NaN boxes; floating-point numbers do not require heap mapping."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1-bit model; floating point numbers require heap mapping; 2-bit model; NaN boxes; floating point numbers do not require heap mapping."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1.bit model; floating point numbers require heap assignment; 2.bit model; NaN boxes; floating numbers do not require heap assignment."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1.bit model; floating-point numbers require heap mapping; 2.bit model; NaN boxes; floating-point numbers do not require heap mappings."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1-bit model; floating point numbers require heap assignment; 2-bit model; NaN boxes; floating numbers do not require heap assignments."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1-bit model; floating point numbers require heap assignment; 2-bit model; NaN boxes; floating point numbers do not require heap assignment."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1.bit model; floating point numbers require heap assignment; 2.bit model; NaN boxes; floating point numbers do not require heap assignment."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1.bit model; floating point numbers require heap mapping; 2.bit model; NaN boxes; floating point numbers do not require heap mapping."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1.Bit model; floating point numbers require heap assignment; 2.Bit model; NaN boxes; floating numbers do not require heap assignment."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model     floating-point numbers require heap allocation, 2.bits model NaN Boxing     floating numbers do not require heap allocation.",
        "The MicroPython Virtual Machine and Compile Chain support two configurations for displaying MicroPython objects: 1.Bit model; floating point numbers require heap mapping; 2.Bit model; NaN boxes; floating point numbers do not require heap mapping."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is designed to build the MicroPython Virtual Machine without support of Memtime and Rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is designed to enable the creation of the MicroPython Virtual Machine without the support of Memtime and Rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should allow to build MicroPython Virtual Machine without support of Memtime and rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is designed to enable the creation of the MicroPython Virtual Machine without the support of Memtime and Rtems modules \/ submodules."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should allow to build MicroPython Virtual Machine without support of Memtime and rtems modules \/ submodules."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should make it possible to build MicroPython Virtual Machine without supporting Memtime and rtems modules \/ submodules."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is designed to build the MicroPython Virtual Machine without the support of Memtime and Rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should allow to build MicroPython Virtual Machine without support of memtime and rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should make it possible to build MicroPython Virtual Machine without support for Memtime and rtems modules \/ submodules."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should make it possible to build MicroPython Virtual Machine without support of Memtime and rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is designed to build the MicroPython Virtual Machine without the support of Memtime and Rtems modules \/ submodules."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should allow you to build MicroPython Virtual Machine without the support of Memtime and rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should allow to build MicroPython Virtual Machine without the support of Memtime and rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is intended to enable the creation of the MicroPython Virtual Machine without support of Memtime and Rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should make it possible to build MicroPython Virtual Machine without support of Memtime and rtems modules \/ submodules."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is designed to enable the creation of the MicroPython Virtual Machine without the support of memory and Rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is designed to enable the creation of the MicroPython Virtual Machine without the support of memory and Rtems modules \/ submodules."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is designed to enable the creation of the MicroPython Virtual Machine without support of Memtime and Rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain is intended to enable the creation of the MicroPython Virtual Machine without the support of Memtime and Rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "The MicroPython Virtual Machine and Compile Chain should allow you to build MicroPython Virtual Machine without support of Memtime and rtems modules \/ submodules"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine will be based on LEON on Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine is supposed to run on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine will run on LEON at Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine will run on LEON on Edisoft Real-Time Executive for Multiprocessor Systems 4.8"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine should run on LEON on Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine will run on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine will be based on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine should run on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython virtual machine is to run on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine is to run on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython virtual machine will run on LEON on Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython virtual machine will run on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine is to run on LEON on Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine will run on LEON on Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine is based on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine should be based on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine is to be based on LEON on Edisoft Real-Time Executive for multiprocessor systems 4.8"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine is to run on LEON on Edisoft Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine is to run on LEON on Edisoft Real-Time Executive for Multiprocessor Systems 4.8"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including Import Expander, should run on a Unix system compatible with Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander, is intended to run on a Unix system compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including Import Expander, is to run on a Unix system compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including Import Expander, will run on a Unix system compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including Import Expander, should run on a Unix system that is compatible with Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander, should run on a Unix system compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including Import Expander, will run on a Unix system compatible with Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander, should run on a Unix system compatible with Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander, is intended to run on a Unix system compatible with Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander, should run on a Unix system that is compatible with Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including Import Expander, is intended to run on a Unix system compatible with Python 3.4."
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander, is to run on a Unix system compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including Import Expander, should run on a Unix system that is compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including Import Expander, should run on a Unix system compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander, should run on a Unix system that is compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander, is supposed to run on a Unix system that is compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including Import Expander, is intended to run on a Unix system that is compatible with Python 3.4"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain will run on a Unix system with the following so-called software components: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython cross-compiler and its build toolchain are to run on a Unix system, with the following software components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multi-processor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython cross-compiler and its build toolchain are to run on a Unix system, with the following software components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain will run on a Unix system with the following software components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython Cross-Compiler and its Build Toolchain will run on a Unix system with the following software components: Python 3.4, gcc, Cross-Compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain are to run on a Unix system, with the following so-called software components: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython Cross-Compiler and its Build Toolchain are to run on a Unix system with the following software components installed: Python 3.4, gcc, Cross-Compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain are to run on a Unix system with the following software components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain are supposed to run on a Unix system with the following software components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain are to run on a Unix system, with the following software components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython Cross-Compiler and its Build Toolchain are to run on a Unix system with the following so-called software components: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain are supposed to run on a Unix system with the following software components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain are to run on a Unix system with the following so-called software components: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multi-processor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython Cross-Compiler and its Build Toolchain are to run on a Unix system with the following so-called software components: Python 3.4, gcc, Cross-Compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython Cross-Compiler and its Build Toolchain are to run on a Unix system with the following software components: Python 3.4, gcc, Cross-Compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython Cross-Compiler and its Build Toolchain are to run on a Unix system, with the following software components installed: Python 3.4, gcc, Cross-Compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython Cross-Compiler and its Build Toolchain are supposed to run on a Unix system, with the following software components installed: Python 3.4, gcc, Cross-Compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain are to run on a Unix system, with the following so-called software components: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multi-processor systems."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build toolchain, the MicroP ython cross-compiler and its build toolchain are to run on a Unix system with the following so-called software components: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems 4.8."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "The MicroPython Virtual Machine Build Toolchain, the MicroP ython Cross-Compiler and its Build Toolchain are to run on a Unix system with the following so-called software components: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for multiprocessor systems."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified with the requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified according to the requirements of the ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython virtual machine must be qualified with the requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified with the requirements of ECSS CAT-B according to [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must meet the requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified according to the requirements of ECSS CAT-B, as defined in [AD02] and [AD03]"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified with the ECSS CAT-B requirements as defined in [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified with the ECSS CAT-B requirements according to [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified with the requirements of ECSS CAT-B according to [AD02] and [AD03]"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified with the requirements of ECSS CAT-B as per [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must meet the requirements of ECSS CAT-B according to [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython virtual machine must be qualified in accordance with the requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified according to the requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified according to the requirements of ECSS CAT-B as defined in [AD02] and [AD03]"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified with the requirements of ECSS CAT-B as defined in [AD02] and [AD03]"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine must be qualified according to the requirements of the ECSS CAT-B as defined in [AD02] and [AD03]"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython virtual machine must be qualified according to the requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine should make an exception, if it is no longer possible to allocate memory on the heap."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython virtual machine should make an exception if it is no longer possible to allocate memory on the heap."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine should make an exception in case it is no longer possible to allocate memory on the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython virtual machine should make an exception if it is no longer possible to allocate memory in the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython virtual machine is supposed to make an exception if it is no longer possible to allocate memory on the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine should make an exception if it is no longer possible to allocate memory to the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine should make an exception if it is no longer possible to allocate memory on the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine is supposed to make an exception if it is no longer possible to allocate memory to the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine is supposed to make an exception if it is no longer possible to allocate memory on the heap."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine is supposed to make an exception if it is no longer possible to allocate memory in the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine should make an exception if it is no longer possible to allocate memory on the heap."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine should make an exception in case it is no longer possible to allocate memory on the heap."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine is supposed to make an exception if it is no longer possible to allocate memory on the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython virtual machine should make an exception if it is no longer possible to allocate memory on the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine should make an exception if it is no longer possible to allocate memory in the pile."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine will make an exception when it is no longer possible to allocate memory on the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine should make an exception if it is no longer possible to reserve memory on the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine will make an exception if it is no longer possible to allocate memory to the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine will make an exception if it is no longer possible to allocate memory on the stacks."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine will make an exception if it is no longer possible to allocate memory on the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython virtual machine is supposed to make an exception if it is no longer possible to allocate memory on the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine should make an exception if it is no longer possible to allocate memory on the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine should make an exception if it is no longer possible to allocate memory on the stack"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine should make an exception if it is no longer possible to reserve memory on the stack"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine is supposed to make an exception if it is no longer possible to allocate memory on the stack"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython virtual machine will make an exception if it is no longer possible to allocate memory on the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython virtual machine should make an exception if it is no longer possible to allocate memory on the stack"
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine should make an exception if it is no longer possible to allocate memory to the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython virtual machine should make an exception if it is no longer possible to allocate memory to the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython virtual machine should make an exception in case it is no longer possible to allocate memory on the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine should make an exception in case it is no longer possible to allocate memory on the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython virtual machine should make an exception if it is no longer possible to allocate memory on the stack."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source, configuration, tool chai n and dynamometer files are maintained in the configuration control."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source code, configuration, tool chains, and dynamometer files are retained in the configuration control."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source code, configuration, tool chains and dynamometer files are maintained in the configuration control."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source, configuration, tool chains, and dynamometer files are retained in the configuration control."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source code, configuration, tool chains and dynamometer files are retained in the configuration control."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source, configuration, tool chai n and dynamometer files are retained in the configuration control."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source, configuration, tool chains and dynamometer files are retained in the configuration control."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source code, configuration, tool chai n and dynamometer files are maintained in the configuration control."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source, configuration, tool chains and dynamometer files are maintained in the configuration control."
    ],
    [
        "RTT",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source code, configuration, tool chai n and dynamometer files are retained in the configuration control."
    ]
]