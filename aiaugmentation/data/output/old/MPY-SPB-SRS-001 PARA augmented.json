[
    [
        "PARA",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython are defined as a subset of Python 3.4 with some limitations."
    ],
    [
        "PARA",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython is defined as a subset of Python 3.4 with some restrictions."
    ],
    [
        "PARA",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "A subset of Python 3.4 is defined in MicroPython syntax and semantics with some restrictions."
    ],
    [
        "PARA",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4 with some restrictions."
    ],
    [
        "PARA",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "A subset of Python 3.4 is defined in MicroPython syntax and semantics with some limitations."
    ],
    [
        "PARA",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "MicroPython is defined as a subset of Python 3.4 with some restrictions."
    ],
    [
        "PARA",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "A subset of Python 3.4 is defined with some restrictions in terms of syntax and semantics."
    ],
    [
        "PARA",
        "The syntax and semantic of MicroPython is defined as a subset of Python 3.4, with some restrictions.",
        "The syntax and semantics of MicroPython are defined as a subset of Python 3.4 with some restrictions."
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "It shall support the following built-in types as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "It shall support the following built-in types, as defined in Python 3.4: bool int float str object super type."
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "It shall support the following built-in types, as defined in Python 3.4: bool int float str object supertype."
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "It shall support the following built-in types as defined in Python 3.4: Bool int float str object super type"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "It shall support the following built-in types, as defined in Python 3.4: bool int float str object super type "
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "It shall support the following built-in types as defined in Python 3.4: bool int float str object super type."
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "It shall support the following built-in types as defined in Python 3.4: Bool int float str object super type."
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bool int float str object super type",
        "It shall support the following built-in types, as defined in Python 3.4: bool int float str object super type"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "Bytearray bytes tuple dict list MicroPython shall support the following built-in types as defined in Python 3.4"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "The following built-in types shall be supported by MicroPython as defined in Python 3.4: bytearray bytes tuple"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "The following built-in types shall be supported by MicroPython as defined in Python 3.4: bytearray bytes tuple lists"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython shall support the following built-in types as defined in Python 3.4: bytearray bytes tuple dict list"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython shall support the following built-in types defined in Python 3.4: bytearray bytes tuple dict list"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "MicroPython shall support the following built-in types as defined by Python 3.4: bytearray bytes tuple dict list"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in types, as defined in Python 3.4: bytearray bytes tuple dict list",
        "Bytearray bytes tuple dict list MicroPython shall support the following built-in types as defined in Python 3.4:"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "It shall support the following built-in functions defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "It will support the following built-in functions defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are True"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "It shall support the following built-in functions defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are true"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython shall support the following built-in functions defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython shall support the following built-in functions defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are True"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython shall support the following built-in functions as defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are true"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "It shall support the following built-in functions defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are True"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython shall support the following built-in functions as defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are True"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "It shall support the following built-in functions defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are True."
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of argument print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable",
        "MicroPython shall support the following built-in functions as defined in Python 3.4: abs(x) -- absolute value all(iterable) -- True if all values in iterable are True any(iterable) -- True if any values in iterable are"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "It shall support the following built-in ex ception class hierarchy as defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "It shall support the following built-in ex ception class hierarchy as defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError OverflowEr"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "It shall support the following built-in ex ception class hierarchy as defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeError EO"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "It shall support the following built-in ex ception class hierarchy as defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeEr"
    ],
    [
        "PARA",
        "MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError",
        "MicroPython shall support the following built-in ex ception class hierarchy as defined in Python 3.4: BaseException GeneratorExit KeyboardInterrupt SystemExit Exception ArithmeticError OverflowError ZeroDivisionError AssertionError AttributeEr"
    ],
    [
        "PARA",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "It shall support the following classes as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "PARA",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython shall support the following classes defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "PARA",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython shall support the following classes as defined in Python 3.4: classmethod staticmethod"
    ],
    [
        "PARA",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "It shall support the following classes as defined in Python 3.4: classmethod staticmethod method."
    ],
    [
        "PARA",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "MicroPython shall support the following classes as defined in Python 3.4: classmethod staticmethod."
    ],
    [
        "PARA",
        "MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod",
        "It shall support the following classes as defined in Python 3.4: classmethod staticmethod."
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "It shall support the following functions from module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenabled() gc.mem_free() gc.me"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "It shall support the following functions from module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenabled() gc.mem_free() gc"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "It shall support the following functions from module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenabled() gc.mem_free() gc."
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "Micro-Python shall support the following functions from the module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenabled"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "Micro-Python shall support the following functions from the module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenabled() gc.mem_free()"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "It shall support the following functions from module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenabled() gc.mem_free() g"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "It shall support the following functions from module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenabled"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "It shall support the following functions from module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenabled() gc.mem_free()"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "Micro-Python shall support the following functions from the module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenabled()"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()",
        "Micro-Python shall support the following functions from the module gc as defined in Python 3.4: gc.collect() gc.disable() gc.enable() gc.isenable"
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "Python 3.4 shall support the following function from the module arraya: array.array(typecode[, initialiser]) from the module array"
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "It shall support the following function from module arraya defined in Python 3.4: array.array(typecode[, initialiser])"
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "It shall support the following function from module arraya defined in Python 3.4: array.array(typecode[, initialiser]) from the module array"
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "Python 3.4 shall support the following function from the module arraya: array.array(typecode[, initialiser]) from the module arraya."
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "It shall support the following function from module arraya defined in Python 3.4: array.array(typecode[, initialiser]) from the module"
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "Python 3.4 shall support the following function from the module arraya: array.array(typecode[, initialiser]) from the module array."
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "Python 3.4 will support the following function from the module arraya: array.array(typecode[, initialiser]) from the module array."
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "MicroPython shall support the following function from the module arraya defined in Python 3.4: array.array(typecode[ initialiser])"
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "Python 3.4 shall support the following function from the module arraya: array.array(typecode[, initialiser]) from the module arraya"
    ],
    [
        "PARA",
        "MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])",
        "Python 3.4 will support the following function from the module arraya: array.array(typecode[, initialiser]) from the module arraya."
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython shall support the following functions from module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple."
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple."
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple "
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython shall support the following functions of the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple."
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython will support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple."
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple",
        "MicroPython shall support the following functions of the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data) unhexlify(hexstr) a_base64(string) b"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "It shall support the following functions defined in Python 3.4 from the module binasciias: hexlify(data) unhexlify(hexstr) a_base64(string) b_base64(data"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "It shall support the following functions defined in Python 3.4 from the module binasciias: hexlify(Data) unhexlify(Hexstr) a_base64(string) b_base64(Data"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "It shall support the following functions defined in Python 3.4 from the module binasciias: hexlify(data) unhexlify(hexstr) a_base64(string) b_base64"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "It shall support the following functions defined in Python 3.4 from the module binasciias: hexlify(data) unhexlify(hexstr) a_base64(string) b_base64(data)."
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "It shall support the following functions defined in Python 3.4 from the module binasciias: hexlify(data) unhexlify(hexstr) a_base64(string) b"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "It shall support the following functions defined in Python 3.4 from the module binasciias: hexlify(data) unhexlify(hexstr) a_base64(string) b_base64(data)"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "It shall support the following functions defined in Python 3.4 from the module binasciias: hexlify(Data) unhexlify(Hexstr) a_base64(string) b_base64(Data)"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "It shall support the following functions defined in Python 3.4 from the module binasciias: hexlify(data) unhexlify(Hexstr) a_base64(string) b_base64(data)"
    ],
    [
        "PARA",
        "MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)",
        "It shall support the following functions defined in Python 3.4 from the module binasciias: hexlify(data) unhexlify(hexstr) a_base64 (string) b_base64(data)"
    ],
    [
        "PARA",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "It shall provide the module micropythonwith the following functions: micropython.stack_use() Return the current amount of C stack that is used. micropython.pystack_use() Return the current amount of Python stack that is used. This function is available only if the virtual machine has been compiled in a configuration which uses"
    ],
    [
        "PARA",
        "MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap.",
        "It shall provide the module micropython with the following functions: micropython.stack_use() Return the current amount of C stack that is used. micropython.pystack_use() Return the current amount of Python stack that is used. This function is available only if the virtual machine has been compiled in a configurat"
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "It shall be possible to use custom modules developed in C."
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "It shall allow the use of custom modules developed in C. ''"
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "It shall allow use of custom modules developed in C."
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython shall allow the use of custom modules developed in C."
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "It shall permit the use of custom modules developed in C."
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython will allow the use of custom modules developed in C."
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython shall allow use of custom modules developed in C."
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "It shall allow the use of custom modules developed in C."
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "It shall allow the use of custom modules written in C."
    ],
    [
        "PARA",
        "MicroPython shall allow for using custom modules developed in C.",
        "MicroPython shall permit the use of custom modules developed in C."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start execution of MicroPython bytecode at a given address in memory. When the bytecode execution ends the function shall return the return code (0 if no error code is specified) and the MicroPython Virtual Machine shall not"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start the execution of MicroPython bytecode at a given address in memory and return the return code (0 if no error code is specified). The MicroPython Virtual Machine shall not modify or remove the bytecode."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start execution of MicroPython bytecode at a given address in memory. When the bytecode execution ends the function shall return the return code (0 if no error code is specified). The MicroPy"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start execution of MicroPython bytecode at a given address in memory. When the bytecode execution ends the function shall return the return code (0 if no error code is specified) and the MicroPython Virtual Machine shall not modify"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start execution of MicroPython bytecode at a given address in memory. When the bytecode execution ends the function shall return the return code (0 if no error code is specified) and the MicroPython Virtual Machine"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start execution of MicroPython bytecode at a given address in memory. When the bytecode execution ends the function shall return the return code (0 if no error code is specified) and the MicroPython virtual machine shall not modify"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start the execution of MicroPython bytecode at a given address in memory and return the return code (0 if no error code is specified). The MicroPython Virtual Machine shall not modify or remove the bytecode"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start the execution of MicroPython bytecode at a given address in memory and return the return code (0 if no error code is specified). The MicroPython Virtual Machine shall not modify or remove the byte"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start execution of MicroPython bytecode at a given address in memory. When the bytecode execution ends the function shall return the return code (0 if no error code is specified). The MicroPython Virtual Machine shall not modify"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.",
        "It shall provide a C function to start the execution of MicroPython bytecode at a given address in memory and return the return code (0 if no error code is specified). The MicroPython virtual machine shall not modify or remove the bytecode"
    ],
    [
        "PARA",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution it shall stop and raise a specific exception. ''"
    ],
    [
        "PARA",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution it shall stop and it shall raise a specific exception."
    ],
    [
        "PARA",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution it shall stop and raise a specific exception."
    ],
    [
        "PARA",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython Virtual Machine cannot allocate the required memory during execution it shall stop and raise a specific exception."
    ],
    [
        "PARA",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython virtual machine cannot allocate the required memory during execution it shall stop and raise a specific exception."
    ],
    [
        "PARA",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython virtual machine cannot allocate the required memory during execution it shall stop and raise a specific exception. ''"
    ],
    [
        "PARA",
        "If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception.",
        "If the MicroPython virtual machine cannot allocate required memory during execution it shall stop and raise a specific exception."
    ],
    [
        "PARA",
        "If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised.",
        "It shall stop returning a specific error code and provide a means to retrieve the line number in the MicroPython source code where the exception was raised if the MicroPy"
    ],
    [
        "PARA",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The MicroPython language shall support object-orientation as defined in Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The MicroPython language shall support object orientation as defined in Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "MicroPython shall support object-oriented programming as defined in Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The MicroPython language shall support object-oriented programming as defined in Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The micro Python language shall support object-oriented programming as defined in Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The Micro Python language shall support object-orientation as defined in Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "Python 3.4 supports object-oriented programming as defined in Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython language shall support object-orientation, as defined in Python 3.4",
        "The Micro Python language shall support object-oriented programming as defined in Python 3.4."
    ],
    [
        "PARA",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler shall be provided. It shall generate a bytecode file with a.mpy extension from a given MicroPython script that is syntactically valid"
    ],
    [
        "PARA",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross compiler shall be provided. It shall generate a bytecode file with a.mpy extension from a given MicroPython script that is syntactically valid"
    ],
    [
        "PARA",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross compiler shall be provided. It shall generate a bytecode file with a.mpy extension from a given MicroPython script that is syntactically valid."
    ],
    [
        "PARA",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross compiler shall be provided. It shall generate a bytecode file with.mpy extension from a given MicroPython script that is syntactically valid."
    ],
    [
        "PARA",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler shall be provided. It shall generate a bytecode file with a.mpy extension from a given MicroPython script that is syntactically"
    ],
    [
        "PARA",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler shall be provided. It shall generate a bytecode file with.mpy extension from a given MicroPython script that is syntactically valid "
    ],
    [
        "PARA",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler shall be provided. It shall generate a bytecode file with.mpy extension from a given MicroPython script that is syntactically valid"
    ],
    [
        "PARA",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler shall be provided. It shall generate a bytecode file with.mpy extension from a given MicroPython script that is syntactically valid."
    ],
    [
        "PARA",
        "MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython script that is syntactically valid.",
        "MicroPython cross-compiler shall be provided. It shall generate a bytecode file having a.mpy extension from a given MicroPython script that is syntactically valid"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the content of the.mpy"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the content of the.mpy file attached with the ISO"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the contents of the.mp"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the content of the.mpy file attached with the ISO checksum"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the content of the.mpy file appended to"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the content of the.mpy file appended"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the content of the.mpy file attached with the"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the content of the.mpy file attached with the ISO check"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the content of the.mpy file "
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).",
        "In accordance with Annex A.2 of [RD03] the Software Development Environment shall provide a tool to calculate the ISO checksum for a given bytecode and produce a.bin file with the content of the.mp"
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler shall report an error if the given script has an invalid syntax. No bytecode file shall be generated in such case. "
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler will report an error if the given script has an invalid syntax. No bytecode file will be generated in such case."
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler shall report an error if the given script has an invalid syntax. No bytecode file shall be generated in such case. The"
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler shall report an error if the given script has an invalid syntax. No bytecode file shall be generated in such cases."
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler shall report an error if the given script has an invalid syntax. No bytecode file shall be generated in such"
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler will report an error if the given script has an invalid syntax. No bytecode file shall be generated in such case."
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler shall report an error if the given script has an invalid syntax. No bytecode file will be generated in such case."
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler shall report an error if the given script has an invalid syntax. No bytecode file shall be generated in such case. In"
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler shall report an error if the given script has an invalid syntax. No bytecode file shall be generated in such case.."
    ],
    [
        "PARA",
        "If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.",
        "The MicroPython compiler shall report an error if the given script has an invalid syntax. No bytecode file shall be generated in such case."
    ],
    [
        "PARA",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "In memory the byte code generated by the MicroPython cross compiler shall be executable by the MicroPython Virtual Machine with the semantic specified by the MicroPython source script."
    ],
    [
        "PARA",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "In memory the byte code generated by the MicroPython cross-compiler shall be executable by the MicroPython virtual machine with the semantic specified by the MicroPython source code."
    ],
    [
        "PARA",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "In memory the byte code generated by the MicroPython cross compiler shall be executable by the MicroPython virtual machine with the semantic specified by the MicroPython source script."
    ],
    [
        "PARA",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "In memory the byte code generated by the MicroPython cross-compiler shall be executable by the MicroPython virtual machine with the semantic specified by the MicroPython source script"
    ],
    [
        "PARA",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "In memory the byte code generated by the MicroPython cross compiler shall be executable by the MicroPython Virtual Machine with the semantic specified by the MicroPython source script"
    ],
    [
        "PARA",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "In memory the byte code generated by the MicroPython cross compiler shall be executable by the MicroPython virtual machine with the semantic specified by the MicroPython source script"
    ],
    [
        "PARA",
        "After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script.",
        "In memory the byte code generated by the MicroPython cross-compiler shall be executable by the MicroPython virtual machine with the semantic specified by the MicroPython source script."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPy"
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "It shall provide a preprocessing tool called \"Import Expander\" which shall take a given Micr oPython script as input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided these modules are not C extensions."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "It shall provide a preprocessing tool called Import Expander which shall take a given Micr oPython script as input and shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files provided these modules are not C extensions."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "It shall provide a preprocessing tool called Import Expander which shall take a given Micr oPython script as input and shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files provided that these modules are not C extensions."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called Import Expander. The Import Expander shall take a given Micr oPython script as input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPy"
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script as input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPyth"
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "It shall provide a preprocessing tool called \"Import Expander\" which shall take a given Micr oPython script as input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files"
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPy"
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "It shall provide a preprocessing tool called \"Import Expander\" which shall take a given Micr oPython script as input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files provided these modules are not C extensions."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.",
        "The MicroPython Software Development Environment shall provide a preprocessing tool called \"Import Expander\". The Import Expander shall take a given Micr oPython script as input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPy"
    ],
    [
        "PARA",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "It shall be able to do smart expansion for a given list of modules: it shall analyse the importing MicroPython procedure and copy only the subset of assignments of variables that are actually used in this procedure."
    ],
    [
        "PARA",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "It shall be able to do smart expansion for a given list of modules: it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure"
    ],
    [
        "PARA",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "It shall be able to do smart expansion for a given list of modules: it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure."
    ],
    [
        "PARA",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "It shall be able to do smart expansion for a given list of modules: it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this"
    ],
    [
        "PARA",
        "The Import Expander shall be able to do \"smart expansion\": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure.",
        "It shall be able to do smart expansion for a given list of modules: it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in the procedure."
    ],
    [
        "PARA",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "It shall be able to report all names retained by smart expansion."
    ],
    [
        "PARA",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The Import Expander shall be able to report all names retained by the smart expansion."
    ],
    [
        "PARA",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "It shall be able to report all the names retained by the smart expansion."
    ],
    [
        "PARA",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "It shall be able to report all the names retained by smart expansion."
    ],
    [
        "PARA",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "It shall be able to report all the names retained by smart expansions."
    ],
    [
        "PARA",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The import expander shall be able to report all names retained by the smart expansion."
    ],
    [
        "PARA",
        "The Import Expander shall be able to report all the names that have been retained by the \"smart expansion\".",
        "The import expander shall be able to report all the names retained by the smart expansion."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The Software Development Environment shall provide a static analysis tool to display violation of coding standard for a given MicroPython procedure and possibly detect some errors."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The Software Development Environment shall provide a static analysis tool to display violation to the coding standard for a given MicroPython procedure and possibly detect some errors. "
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "An analysis tool provided by the Software Development Environment shall be provided to display violation to the coding standard for a given MicroPython procedure and possibly detect some errors."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The software development environment shall provide a static analysis tool to display violation of coding standard for a given MicroPython procedure and possibly detect some errors."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "The Software Development Environment shall provide a static analysis tool to display violation to the coding standard for a given MicroPython procedure and possibly detect some errors."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors.",
        "An analysis tool provided by the Software Development Environment shall be provided to display violation of the coding standard for a given MicroPython procedure and possibly detect some errors."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure. -"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure. b"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The software development environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure. "
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment shall provide a static analysis tool to display the call tree for a given MicroPython procedure."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure. "
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.",
        "The Software Development Environment shall provide a static analysis tool to display the call tree of a given Micro Python procedure."
    ],
    [
        "PARA",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr) Return the 32-bit value at the given address of the addr. addr must be word aligned. mem.write_u32(addr, value) Write value to the given address of the addr."
    ],
    [
        "PARA",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr) Return the 32-bit value at the given addr address. addr must be word aligned. mem.write_u32(addr value) Write value to the given addr address. addr must be word aligned."
    ],
    [
        "PARA",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None.",
        "MicroPython shall provide the module memwith the following functions: mem.read_u32(addr) Return the 32-bit value at the given address of addr. addr must be word aligned. mem.write_u32(addr, value) Write value to the given address of addr."
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id() Return an integer being the identifier of the virtual machine instance in which this script is running. The first Virtual Machine has an identifier of 0. and the following objects (integer constants):"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id() Return an integer being the identifier of the virtual machine instance that this script is running in. The first Virtual Machine has an identifier of 0. and the following objects (integer constants):"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id() Return an integer being the identifier of the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0. and the following objects (integer constants):"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id() Return an integer being the identifier of the virtual machine instance in which this script is running. The first virtual machine has an identifier of 0. and the following objects (integer constants):"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.",
        "MicroPython shall provide the module rtemswith the following function: rtems.script_id() Return an integer being the identifier of the virtual machine instance that this script is running in. The first virtual machine has an identifier of 0. and the following objects (integer constants):"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "The module rtems.queue provides the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES) Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object corresponding to the queue."
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES) Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue."
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES) Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on this queue."
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES) Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object which can be used to send and receive messages on the queue."
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES) Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES) Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object which can be used to send and receive messages"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().",
        "It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES) Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "The module rtems.sem provides the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control concurrent"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "The module rtems.sem shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control concurrent"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "In this module rtems.sem is used for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It provides the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) This function accesses an existing Real-Time Executive for Multi"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "The module rtems.sem provides the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that sema"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "The following functions are provided by MicroPython: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control concurrent access to a"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "The module rtems.sem provides the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "In this module rtems.sem is used for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) This function accesses an existing Real-Time Executive for Multi"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "The module rtems.sem shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control concurrent access"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "The module rtems.sem provides the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control concurrent access to a"
    ],
    [
        "PARA",
        "MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 660.",
        "The module rtems.sem shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0) Create a new Real-Time Executive for Multiprocessor Systems semaphore and return a semaphore object that can be used to control concurrent access to"
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment.",
        "The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension.mpy). The messages output by the cross-compiler"
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If a Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in"
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the Software Development Environment is configured to do so the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code) and the messages output by the Import Expander shall be visible in the Software Development Environment"
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If a Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment"
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the Software Development Environment is configured to do so the Import Expander shall be automatically called before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment."
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the Software Development Environment is configured to do so the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development"
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the Software Development Environment is configured to do so the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment"
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the Software Development Environment is configured to do so the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code) and the messages output by the Import Expander shall be visible in"
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If a Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment."
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the Software Development Environment is configured to do so the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in"
    ],
    [
        "PARA",
        "If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment.",
        "If the Software Development Environment is configured to do so the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "It shall provide a simple way to call the ISO checksum tool in order to produce the.bin file for a given MPY file."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "It shall provide a simple means to call the ISO checksum tool in order to produce the.bin file for a.mpy file specified."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "It shall provide a simple means to call the ISO checksum tool in order to produce the.bin file for a given MPY file."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "It shall provide a simple means to call the ISO checksum tool in order to produce the.bin file for a.mpy file given a"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "It shall provide a simple means to call the ISO checksum tool in order to produce the.bin file for a.mpy file."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "It shall provide a simple means to call the ISO checksum tool in order to produce the.bin file for a.mpy file given"
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.",
        "The Software Development Environment shall provide a simple means to call the ISO checksum tool to produce the.bin file for a given.mpy file."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "It shall provide a simple means to load and execute a given bytcode file on a given LEON2 target."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "It shall provide a simple means of loading and executing a given bytecode file on a given LEON2 target."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "It shall provide a simple means of loading and executing a given bytecode file on a given target LEON2."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The software development environment shall provide a simple way to load and execute a given bytecode file on a given LEON2 target."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "The Software Development Environment shall provide a simple way to load and execute a given bytecode file on a given LEON2 target."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "It shall provide a simple means to load and execute a given file of bytecode on a given LEON2 target."
    ],
    [
        "PARA",
        "The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.",
        "It shall provide a simple means to load and execute a given bytcode file on a given target LEON2."
    ],
    [
        "PARA",
        "The Virtual Machine test suite shall be automated.",
        "It shall be automated for the virtual machine test suite."
    ],
    [
        "PARA",
        "The Virtual Machine test suite shall be automated.",
        "The virtual machine testing suite shall be automated."
    ],
    [
        "PARA",
        "The Virtual Machine test suite shall be automated.",
        "The virtual machine test suite shall be automated. -"
    ],
    [
        "PARA",
        "The Virtual Machine test suite shall be automated.",
        "It shall be automated in the Virtual Machine test suite."
    ],
    [
        "PARA",
        "The Virtual Machine test suite shall be automated.",
        "The Virtual Machine testing suite shall be automated."
    ],
    [
        "PARA",
        "The Virtual Machine test suite shall be automated.",
        "It shall be automated in the virtual machine test suite."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine shall be designed to have a minimum size which shall not exceed 200 kbytes."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine shall be designed to have a minimal size which shall not exceed 200 kbytes."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython virtual machine shall be designed to have a minimum size which shall not exceed 200 kbytes."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The virtual machine executable code shall be designed to have a minimal size which shall not exceed 200 kbytes."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine shall be designed to have a minimum size that shall not exceed 200 kbytes."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The virtual machine executable code shall be designed to have a minimum size which shall not exceed 200 kbytes."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The execable code of the MicroPython Virtual Machine shall be designed to have a minimum size which shall not exceed 200 k"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The executable code of the MicroPython Virtual Machine shall be designed to have a minimum size of not more than 200 kbytes."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The virtual machine executable code shall be designed to have a minimum size that shall not exceed 200 kbytes."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.",
        "The virtual machine executable code shall be designed to have a minimum size of not more than 200 kbytes."
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce a minimum size of bytecode"
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce a bytecode with minimal sizes."
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce a minimal size of bytecode"
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce a bytecode with minimal size."
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce a minimal size of bytecode."
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce bytecode with minimal size."
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce a minimum size of bytecode."
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce a minimal size of bytecode. "
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce bytecode of minimal size."
    ],
    [
        "PARA",
        "The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.",
        "MicroPython cross compiler shall be designed to produce a minimal size of byte code."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "It shall be designed to execute the bytecode using a good trade-off between memory consumption and execution time. For this choice minimisation of memory consumption should be prioritized."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "It shall be designed to execute the bytecode using a good trade-off between memory consumption and execution time. For this choice minimisation of memory consumption should be prioritized. "
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "It shall be designed to execute the bytecode using a good trade-off between memory consumption and execution time. For this choice the minimisation of memory consumption should be prioritized."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized.",
        "It shall be designed to execute the bytecode using a good trade-off between memory consumption and execution time. For this choice the minimisation of memory consumption should be prioritized. "
    ],
    [
        "PARA",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "An d\/or compile chain of the MicroPython cross-compiler source code shall contain configuration parameters to account for constraints of a specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off"
    ],
    [
        "PARA",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "An d\/or compile chain of the MicroPython cross-compiler source code shall contain configuration parameters to account for constraints of a specific hardware target (e.g. ROM\/RAM size) or for selecting a specific trade-off"
    ],
    [
        "PARA",
        "The MicroPython cross-compiler source code an d\/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "An d\/or compile chain of the MicroPython cross-compiler source code shall contain configuration parameters to account for constraints of a specific hardware target (e.g. ROM \/ RAM size) or to select a specific trade-off"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target. "
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The MicroPython virtual machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target. "
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware targets (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine source code and\/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target.",
        "The MicroPython Virtual Machine source code and\/or compilation chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM \/ RAM size) or for selecting a specific trade-off for a given target."
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The environment of MicroPython is made up of a Software Development Environment (development of MicroPython script), a cross compiler (production of bytecode from MicroPython script), and a Virtual Machine (execution of the bytecode)."
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross compiler (production of bytecode from MicroPython script) and a virtual machine (execution of the bytecode)."
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode"
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the byte"
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The environment of MicroPython is made up of a Software Development Environment (development of MicroPython script), a cross compiler (production of bytecode from MicroPython script) and a Virtual Machine (execution of the bytecode)."
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The environment of MicroPython is made up of a Software Development Environment (development of MicroPython script), a cross compiler (production of bytecode from MicroPython script) and a Virtual Machine (execution of the bytecode"
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script) and a Virtual Machine (execution of the byte"
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross compiler (production of bytecode from MicroPython script), a virtual machine (execution of the bytecode)."
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The environment of MicroPython is made up of a Software Development Environment (development of MicroPython script), a cross compiler (production of bytecode from MicroPython script) and a virtual machine (execution of the bytecode)."
    ],
    [
        "PARA",
        "The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).",
        "The environment of MicroPython is made up of a Software Development Environment (development of MicroPython script), a cross compiler (production of bytecode from MicroPython script) and a virtual machine (execution of the bytecode"
    ],
    [
        "PARA",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of MicroPython cross compiler and virtual machine any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives."
    ],
    [
        "PARA",
        "In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives.",
        "In the C source code of the MicroPython cross compiler and virtual machine any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model   ̶  floating-point numbers require heap allocation, 2.bits model “NaN Boxing”   ̶  floating numbers do not require heap allocation.",
        "The MicroPython virtual machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model  floating-point numbers require heap allocation and 2.bits model NaN boxing  floating numbers do not require heap"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model   ̶  floating-point numbers require heap allocation, 2.bits model “NaN Boxing”   ̶  floating numbers do not require heap allocation.",
        "The MicroPython virtual machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model  floating-point numbers require heap allocation, 2.bits model NaN boxing  floating numbers do not require heap"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model   ̶  floating-point numbers require heap allocation, 2.bits model “NaN Boxing”   ̶  floating numbers do not require heap allocation.",
        "MicroPython virtual machine and compiler chain shall support two configurations for MicroPython object representation: 1.bits model  floating-point numbers require heap allocation 2.bits model NaN boxing  floating numbers do not require heap allocation."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model   ̶  floating-point numbers require heap allocation, 2.bits model “NaN Boxing”   ̶  floating numbers do not require heap allocation.",
        "MicroPython virtual machine and compiler chain shall support two configurations for MicroPython object representation: 1.bits model  floating-point numbers require heap allocation 2.bits model NaN Boxing  floating numbers do not require heap allocation."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model   ̶  floating-point numbers require heap allocation, 2.bits model “NaN Boxing”   ̶  floating numbers do not require heap allocation.",
        "MicroPython virtual machine and compiler chain shall support two configurations for MicroPython object representation: 1.bits model  floating-point numbers require heap allocation and 2.bits model NaN boxing  floating numbers do not require heap allocation."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model   ̶  floating-point numbers require heap allocation, 2.bits model “NaN Boxing”   ̶  floating numbers do not require heap allocation.",
        "MicroPython virtual machine and compiler chain shall support two configurations for MicroPython object representation: 1.bits model  floating-point numbers require heap allocation, 2.bits model NaN boxing  floating numbers do not require heap allocation."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model   ̶  floating-point numbers require heap allocation, 2.bits model “NaN Boxing”   ̶  floating numbers do not require heap allocation.",
        "The MicroPython virtual machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model  floating-point numbers require heap allocation 2.bits model NaN boxing  floating numbers do not require heap"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "It shall be possible to build a MicroPython virtual machine without the support of memtime and rtems modules \/ submodules."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "It shall be possible to build a MicroPython virtual machine without support of memtime and rtems modules\/submodules and without"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "It shall be possible to build a MicroPython virtual machine without the support of memtime and rtems modules \/ submodules"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "It shall be possible to build a MicroPython virtual machine without support of memtime and rtems modules\/submodules."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "It shall be possible to build a MicroPython virtual machine without support for memtime and rtems modules\/submodules."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "It shall be possible to build a MicroPython virtual machine without support of memtime and rtems modules\/submodules"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "It shall be possible to build a MicroPython virtual machine without support of memtime and rtems modules\/submodules and without "
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules\/submodules",
        "It shall be possible to build a MicroPython Virtual Machine without support of memtime and rtems modules\/submodules."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander shall run on a Unix system compatible with Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment including the Import Expander shall run on a Unix system compatible with Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython Software Development Environment including Import Expander shall run on a Unix system compatible with Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython Software Development Environment, including the Import Expander, shall run on a Unix system compatible with Python 3.4",
        "The MicroPython software development environment including the Import Expander shall run on a Unix system compatible with Python 3.4."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "On a Unix system the MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall be installed with the following so-called ftware components: Python 3.4, gcc cross-compiler for SPARC V8 and Ed"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "On a Unix system the MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall be installed with the following so-called ftware components: Python 3.4, gcc, cross-compil"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "On a Unix system the MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall be installed with the following so-called ftware components: Python 3.4, gcc, cross-compiler for SPARC"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "On a Unix system the MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall be installed with the following so-called ftware components: Python 3.4, gcc cross-comp"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "On a Unix system the MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall be installed with the following so-called ftware components: Python 3.4, gcc cross-compiler for SPARC"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "On a Unix system the MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall be installed with the following so-called ftware components: Python 3.4, gcc cross-compiler for SP"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "On a Unix system the MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall be installed with the following so-called ftware components: Python 3.4, gcc cross-compiler for SPARC V8 and"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8.",
        "On a Unix system the MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall be installed with the following so-called ftware components: Python 3.4, gcc cross-compil"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "It shall comply with the requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython virtual machine shall be qualified with requirements of ECSS CAT-B as defined in [AD02] and [AD03."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython virtual machine shall be qualified with the requirements of ECSS CAT-B as defined in [AD02] and [AD03."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "It shall be qualified with the requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "It shall be qualified with the requirements of ECSS CAT-B as defined in [AD02] and [AD03."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython virtual machine shall be qualified with requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "It shall comply with requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B as defined in [AD02] and [AD03]."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].",
        "It shall comply with the requirements of ECSS CAT-B defined in [AD02] and [AD03]."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The micropython virtual machine shall raise an exception in case it is no longer possible to allocate memory on the heap."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython virtual machine shall raise an exception in case it is no longer possible to allocate memory on the heap."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython virtual machine shall raise an exception in case it is no longer possible to allocate memory on the heap. ''"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython virtual machine shall raise an exception if it is no longer possible to allocate memory on the heap."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine shall raise an exception in case it is no longer possible to allocate memory on the heap."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython virtual machine shall raise an exception in case it is not possible to allocate memory on the heap."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "In case it is no longer possible to allocate memory on the heap the virtual machine shall raise an exception."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython Virtual Machine shall raise an exception in case it is no longer possible to allocate memory on the heap. ''"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.",
        "The MicroPython virtual machine shall raise an exception if it is no longer possible to allocate memory on the heap. ''"
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "It shall raise an exception in case it is not possible to allocate memory on the stack."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "It shall raise an exception in case it is no longer possible to allocate memory on the stack."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython Virtual Machine shall raise an exception in case it is no longer possible to allocate memory on the stack."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "If it is not possible to allocate memory on the stack the MicroPython virtual machine shall raise an exception."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython virtual machine shall raise an exception in case it is no longer possible to allocate memory on the stack."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "It shall raise an exception if it is no longer possible to allocate memory on the stack."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The micropython virtual machine shall raise an exception in case it is no longer possible to allocate memory on the stack."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "If it is not possible to allocate memory on the stack the MicroPython virtual machine raises an exception."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython virtual machine shall raise an exception if it is no longer possible to allocate memory on the stack."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.",
        "The MicroPython virtual machine shall raise an exception in case it is not possible to allocate memory on the stack."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The source, configuration, tool chai n and test bench files shall be maintained in configuration control."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control mode."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The source files for the MicroPython virtual machine configuration, tool chai n and test bench shall be maintained in configuration control."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained under configuration control."
    ],
    [
        "PARA",
        "The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.",
        "The source files for the MicroPython Virtual Machine configuration, tool chai n and test bench shall be maintained in configuration control."
    ]
]